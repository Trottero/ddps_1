<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Mon Mar 30 15:27:52 PDT 2015 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="hadoop-core 2.6.0"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet org.apache.hadoop.classification.tools.ExcludePrivateAnnotationsJDiffDoclet -docletpath /Users/llu/hadoop-common/hadoop-common-project/hadoop-common/target/hadoop-annotations.jar:/Users/llu/hadoop-common/hadoop-common-project/hadoop-common/target/jdiff.jar -verbose -classpath /Users/llu/hadoop-common/hadoop-common-project/hadoop-common/target/classes:/Users/llu/hadoop-common/hadoop-common-project/hadoop-annotations/target/hadoop-annotations-2.6.0.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_67.jdk/Contents/Home/lib/tools.jar:/Users/llu/.m2/repository/com/google/guava/guava/11.0.2/guava-11.0.2.jar:/Users/llu/.m2/repository/commons-cli/commons-cli/1.2/commons-cli-1.2.jar:/Users/llu/.m2/repository/org/apache/commons/commons-math3/3.1.1/commons-math3-3.1.1.jar:/Users/llu/.m2/repository/xmlenc/xmlenc/0.52/xmlenc-0.52.jar:/Users/llu/.m2/repository/commons-httpclient/commons-httpclient/3.1/commons-httpclient-3.1.jar:/Users/llu/.m2/repository/commons-codec/commons-codec/1.4/commons-codec-1.4.jar:/Users/llu/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/llu/.m2/repository/commons-net/commons-net/3.1/commons-net-3.1.jar:/Users/llu/.m2/repository/commons-collections/commons-collections/3.2.1/commons-collections-3.2.1.jar:/Users/llu/.m2/repository/javax/servlet/servlet-api/2.5/servlet-api-2.5.jar:/Users/llu/.m2/repository/org/mortbay/jetty/jetty/6.1.26/jetty-6.1.26.jar:/Users/llu/.m2/repository/org/mortbay/jetty/jetty-util/6.1.26/jetty-util-6.1.26.jar:/Users/llu/.m2/repository/com/sun/jersey/jersey-core/1.9/jersey-core-1.9.jar:/Users/llu/.m2/repository/com/sun/jersey/jersey-json/1.9/jersey-json-1.9.jar:/Users/llu/.m2/repository/org/codehaus/jettison/jettison/1.1/jettison-1.1.jar:/Users/llu/.m2/repository/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jar:/Users/llu/.m2/repository/javax/xml/bind/jaxb-api/2.2.2/jaxb-api-2.2.2.jar:/Users/llu/.m2/repository/javax/xml/stream/stax-api/1.0-2/stax-api-1.0-2.jar:/Users/llu/.m2/repository/javax/activation/activation/1.1/activation-1.1.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-jaxrs/1.9.13/jackson-jaxrs-1.9.13.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-xc/1.9.13/jackson-xc-1.9.13.jar:/Users/llu/.m2/repository/com/sun/jersey/jersey-server/1.9/jersey-server-1.9.jar:/Users/llu/.m2/repository/asm/asm/3.2/asm-3.2.jar:/Users/llu/.m2/repository/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar:/Users/llu/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/llu/.m2/repository/net/java/dev/jets3t/jets3t/0.9.0/jets3t-0.9.0.jar:/Users/llu/.m2/repository/org/apache/httpcomponents/httpclient/4.2.5/httpclient-4.2.5.jar:/Users/llu/.m2/repository/org/apache/httpcomponents/httpcore/4.2.5/httpcore-4.2.5.jar:/Users/llu/.m2/repository/com/jamesmurty/utils/java-xmlbuilder/0.4/java-xmlbuilder-0.4.jar:/Users/llu/.m2/repository/commons-lang/commons-lang/2.6/commons-lang-2.6.jar:/Users/llu/.m2/repository/commons-configuration/commons-configuration/1.6/commons-configuration-1.6.jar:/Users/llu/.m2/repository/commons-digester/commons-digester/1.8/commons-digester-1.8.jar:/Users/llu/.m2/repository/commons-beanutils/commons-beanutils/1.7.0/commons-beanutils-1.7.0.jar:/Users/llu/.m2/repository/commons-beanutils/commons-beanutils-core/1.8.0/commons-beanutils-core-1.8.0.jar:/Users/llu/.m2/repository/org/slf4j/slf4j-api/1.7.5/slf4j-api-1.7.5.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/Users/llu/.m2/repository/org/apache/avro/avro/1.7.4/avro-1.7.4.jar:/Users/llu/.m2/repository/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar:/Users/llu/.m2/repository/org/xerial/snappy/snappy-java/1.0.4.1/snappy-java-1.0.4.1.jar:/Users/llu/.m2/repository/org/apache/ant/ant/1.8.1/ant-1.8.1.jar:/Users/llu/.m2/repository/org/apache/ant/ant-launcher/1.8.1/ant-launcher-1.8.1.jar:/Users/llu/.m2/repository/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar:/Users/llu/.m2/repository/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar:/Users/llu/hadoop-common/hadoop-common-project/hadoop-auth/target/hadoop-auth-2.6.0.jar:/Users/llu/.m2/repository/org/apache/directory/server/apacheds-kerberos-codec/2.0.0-M15/apacheds-kerberos-codec-2.0.0-M15.jar:/Users/llu/.m2/repository/org/apache/directory/server/apacheds-i18n/2.0.0-M15/apacheds-i18n-2.0.0-M15.jar:/Users/llu/.m2/repository/org/apache/directory/api/api-asn1-api/1.0.0-M20/api-asn1-api-1.0.0-M20.jar:/Users/llu/.m2/repository/org/apache/directory/api/api-util/1.0.0-M20/api-util-1.0.0-M20.jar:/Users/llu/.m2/repository/org/apache/curator/curator-framework/2.6.0/curator-framework-2.6.0.jar:/Users/llu/.m2/repository/com/jcraft/jsch/0.1.42/jsch-0.1.42.jar:/Users/llu/.m2/repository/org/apache/curator/curator-client/2.6.0/curator-client-2.6.0.jar:/Users/llu/.m2/repository/org/apache/curator/curator-recipes/2.6.0/curator-recipes-2.6.0.jar:/Users/llu/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/llu/.m2/repository/org/htrace/htrace-core/3.0.4/htrace-core-3.0.4.jar:/Users/llu/.m2/repository/org/apache/zookeeper/zookeeper/3.4.6/zookeeper-3.4.6.jar:/Users/llu/.m2/repository/io/netty/netty/3.6.2.Final/netty-3.6.2.Final.jar:/Users/llu/.m2/repository/org/apache/commons/commons-compress/1.4.1/commons-compress-1.4.1.jar:/Users/llu/.m2/repository/org/tukaani/xz/1.0/xz-1.0.jar -sourcepath /Users/llu/hadoop-common/hadoop-common-project/hadoop-common/src/main/java -apidir /Users/llu/hadoop-common/hadoop-common-project/hadoop-common/target/site/jdiff/xml -apiname hadoop-core 2.6.0 -->
<package name="org.apache.hadoop">
  <!-- start class org.apache.hadoop.HadoopIllegalArgumentException -->
  <class name="HadoopIllegalArgumentException" extends="java.lang.IllegalArgumentException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HadoopIllegalArgumentException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs exception with the specified detail message. 
 @param message detailed message.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Indicates that a method has been passed illegal or invalid argument. This
 exception is thrown instead of IllegalArgumentException to differentiate the
 exception thrown in Hadoop implementation from the one thrown in JDK.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.HadoopIllegalArgumentException -->
</package>
<package name="org.apache.hadoop.conf">
  <!-- start interface org.apache.hadoop.conf.Configurable -->
  <interface name="Configurable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration to be used by this object.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the configuration used by this object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Something that may be configured with a {@link Configuration}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.conf.Configurable -->
  <!-- start class org.apache.hadoop.conf.Configuration -->
  <class name="Configuration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable"/>
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration.]]>
      </doc>
    </constructor>
    <constructor name="Configuration" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration where the behavior of reading from the default 
 resources can be turned off.
 
 If the parameter {@code loadDefaults} is false, the new instance
 will not load resources from the default files. 
 @param loadDefaults specifies whether to load from the default files]]>
      </doc>
    </constructor>
    <constructor name="Configuration" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration with the same settings cloned from another.
 
 @param other the configuration from which to clone settings.]]>
      </doc>
    </constructor>
    <method name="addDeprecations"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deltas" type="org.apache.hadoop.conf.Configuration.DeprecationDelta[]"/>
      <doc>
      <![CDATA[Adds a set of deprecated keys to the global deprecations.

 This method is lockless.  It works by means of creating a new
 DeprecationContext based on the old one, and then atomically swapping in
 the new context.  If someone else updated the context in between us reading
 the old context and swapping in the new one, we try again until we win the
 race.

 @param deltas   The deprecations to add.]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #addDeprecation(String key, String newKey,
      String customMessage)} instead">
      <param name="key" type="java.lang.String"/>
      <param name="newKeys" type="java.lang.String[]"/>
      <param name="customMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If a key is deprecated in favor of multiple keys, they are all treated as 
 aliases of each other, and setting any one of them resets all the others 
 to the new value.

 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.
 
 @param key
 @param newKeys
 @param customMessage
 @deprecated use {@link #addDeprecation(String key, String newKey,
      String customMessage)} instead]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="newKey" type="java.lang.String"/>
      <param name="customMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key
 @param newKey
 @param customMessage]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #addDeprecation(String key, String newKey)} instead">
      <param name="key" type="java.lang.String"/>
      <param name="newKeys" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map when no custom
 message is provided.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If a key is deprecated in favor of multiple keys, they are all treated as 
 aliases of each other, and setting any one of them resets all the others 
 to the new value.
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key Key that is to be deprecated
 @param newKeys list of keys that take up the values of deprecated key
 @deprecated use {@link #addDeprecation(String key, String newKey)} instead]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="newKey" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map when no custom
 message is provided.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key Key that is to be deprecated
 @param newKey key that takes up the value of deprecated key]]>
      </doc>
    </method>
    <method name="isDeprecated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[checks whether the given <code>key</code> is deprecated.
 
 @param key the parameter which is to be checked for deprecation
 @return <code>true</code> if the key is deprecated and 
         <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="setDeprecatedProperties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets all deprecated properties that are not currently set but have a
 corresponding new property that is set. Useful for iterating the
 properties when all deprecated properties for currently set properties
 need to be present.]]>
      </doc>
    </method>
    <method name="addDefaultResource"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a default resource. Resources are loaded in the order of the resources 
 added.
 @param name file name. File should be present in the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param name resource to be added, the classpath is examined for a file 
             with that name.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param url url of the resource to be added, the local filesystem is 
            examined directly to find the resource, without referring to 
            the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param file file-path of resource to be added, the local filesystem is
             examined directly to find the resource, without referring to 
             the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 WARNING: The contents of the InputStream will be cached, by this method. 
 So use this sparingly because it does increase the memory consumption.
 
 @param in InputStream to deserialize the object from. In will be read from
 when a get or set is called next.  After it is read the stream will be
 closed.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param in InputStream to deserialize the object from.
 @param name the name of the resource because InputStream.toString is not
 very descriptive some times.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Add a configuration resource.

 The properties of this resource will override properties of previously
 added resources, unless they were marked <a href="#Final">final</a>.

 @param conf Configuration object from which to load properties]]>
      </doc>
    </method>
    <method name="reloadConfiguration"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload configuration from previously added resources.

 This method will clear all the configuration read from the added 
 resources, and final parameters. This will make the resources to 
 be read again before accessing the values. Values that are added
 via set methods will overlay values read from the resources.]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property, <code>null</code> if
 no such property exists. If the key is deprecated, it returns the value of
 the first key which replaces the deprecated key and is not null.
 
 Values are processed for <a href="#VariableExpansion">variable expansion</a> 
 before being returned. 
 
 @param name the property name, will be trimmed before get value.
 @return the value of the <code>name</code> or its replacing property, 
         or null if no such property exists.]]>
      </doc>
    </method>
    <method name="getTrimmed" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a trimmed <code>String</code>, 
 <code>null</code> if no such property exists. 
 If the key is deprecated, it returns the value of
 the first key which replaces the deprecated key and is not null
 
 Values are processed for <a href="#VariableExpansion">variable expansion</a> 
 before being returned. 
 
 @param name the property name.
 @return the value of the <code>name</code> or its replacing property, 
         or null if no such property exists.]]>
      </doc>
    </method>
    <method name="getTrimmed" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a trimmed <code>String</code>, 
 <code>defaultValue</code> if no such property exists. 
 See @{Configuration#getTrimmed} for more details.
 
 @param name          the property name.
 @param defaultValue  the property default value.
 @return              the value of the <code>name</code> or defaultValue
                      if it is not set.]]>
      </doc>
    </method>
    <method name="getRaw" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property, without doing
 <a href="#VariableExpansion">variable expansion</a>.If the key is 
 deprecated, it returns the value of the first key which replaces 
 the deprecated key and is not null.
 
 @param name the property name.
 @return the value of the <code>name</code> property or 
         its replacing property and null if no such property exists.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the <code>value</code> of the <code>name</code> property. If 
 <code>name</code> is deprecated or there is a deprecated name associated to it,
 it sets the value to both names. Name will be trimmed before put into
 configuration.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the <code>value</code> of the <code>name</code> property. If 
 <code>name</code> is deprecated, it also sets the <code>value</code> to
 the keys that replace the deprecated key. Name will be trimmed before put
 into configuration.

 @param name property name.
 @param value property value.
 @param source the place that this configuration value came from 
 (For debugging).
 @throws IllegalArgumentException when the value or name is null.]]>
      </doc>
    </method>
    <method name="unset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Unset a previously set property.]]>
      </doc>
    </method>
    <method name="setIfUnset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets a property if it is currently unset.
 @param name the property name
 @param value the new value]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code>. If the key is deprecated,
 it returns the value of the first key which replaces the deprecated key
 and is not null.
 If no such property exists,
 then <code>defaultValue</code> is returned.
 
 @param name property name, will be trimmed before get value.
 @param defaultValue default value.
 @return property value, or <code>defaultValue</code> if the property 
         doesn't exist.]]>
      </doc>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="int"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as an <code>int</code>.
   
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>int</code>,
 then an error is thrown.
 
 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as an <code>int</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getInts" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a set of comma-delimited
 <code>int</code> values.
 
 If no such property exists, an empty array is returned.
 
 @param name property name
 @return property value interpreted as an array of comma-delimited
         <code>int</code> values]]>
      </doc>
    </method>
    <method name="setInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to an <code>int</code>.
 
 @param name property name.
 @param value <code>int</code> value of the property.]]>
      </doc>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>long</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>long</code>,
 then an error is thrown.
 
 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>long</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getLongBytes" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>long</code> or
 human readable format. If no such property exists, the provided default
 value is returned, or if the specified value is not a valid
 <code>long</code> or human readable format, then an error is thrown. You
 can use the following suffix (case insensitive): k(kilo), m(mega), g(giga),
 t(tera), p(peta), e(exa)

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>long</code>,
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>long</code>.
 
 @param name property name.
 @param value <code>long</code> value of the property.]]>
      </doc>
    </method>
    <method name="getFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="float"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>float</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>float</code>,
 then an error is thrown.

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>float</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>float</code>.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="double"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>double</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>double</code>,
 then an error is thrown.

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>double</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>double</code>.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="boolean"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>boolean</code>.  
 If no such property is specified, or if the specified value is not a valid
 <code>boolean</code>, then <code>defaultValue</code> is returned.
 
 @param name property name.
 @param defaultValue default value.
 @return property value as a <code>boolean</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>boolean</code>.
 
 @param name property name.
 @param value <code>boolean</code> value of the property.]]>
      </doc>
    </method>
    <method name="setBooleanIfUnset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the given property, if it is currently unset.
 @param name property name
 @param value new value]]>
      </doc>
    </method>
    <method name="setEnum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to the given type. This
 is equivalent to <code>set(&lt;name&gt;, value.toString())</code>.
 @param name property name
 @param value new value]]>
      </doc>
    </method>
    <method name="getEnum" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Return value matching this enumerated type.
 @param name Property name
 @param defaultValue Value returned if no mapping exists
 @throws IllegalArgumentException If mapping is illegal for the type
 provided]]>
      </doc>
    </method>
    <method name="setTimeDuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Set the value of <code>name</code> to the given time duration. This
 is equivalent to <code>set(&lt;name&gt;, value + &lt;time suffix&gt;)</code>.
 @param name Property name
 @param value Time duration
 @param unit Unit of time]]>
      </doc>
    </method>
    <method name="getTimeDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Return time duration in the given time unit. Valid units are encoded in
 properties as suffixes: nanoseconds (ns), microseconds (us), milliseconds
 (ms), seconds (s), minutes (m), hours (h), and days (d).
 @param name Property name
 @param defaultValue Value returned if no mapping exists.
 @param unit Unit to convert the stored property, if it exists.
 @throws NumberFormatException If the property stripped of its unit is not
         a number]]>
      </doc>
    </method>
    <method name="getPattern" return="java.util.regex.Pattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Pattern</code>.
 If no such property is specified, or if the specified value is not a valid
 <code>Pattern</code>, then <code>DefaultValue</code> is returned.

 @param name property name
 @param defaultValue default value
 @return property value as a compiled Pattern, or defaultValue]]>
      </doc>
    </method>
    <method name="setPattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="pattern" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Set the given property to <code>Pattern</code>.
 If the pattern is passed as null, sets the empty pattern which results in
 further calls to getPattern(...) returning the default value.

 @param name property name
 @param pattern new value]]>
      </doc>
    </method>
    <method name="getPropertySources" return="java.lang.String[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets information about why a property was set.  Typically this is the 
 path to the resource objects (file, URL, etc.) the property came from, but
 it can also indicate that it was set programatically, or because of the
 command line.

 @param name - The property name to get the source of.
 @return null - If the property or its source wasn't found. Otherwise, 
 returns a list of the sources of the resource.  The older sources are
 the first ones in the list.  So for example if a configuration is set from
 the command line, and then written out to a file that is read back in the
 first entry would indicate that it was set from the command line, while
 the second one would indicate the file that the new configuration was read
 in from.]]>
      </doc>
    </method>
    <method name="getRange" return="org.apache.hadoop.conf.Configuration.IntegerRanges"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Parse the given attribute as a set of integer ranges
 @param name the attribute name
 @param defaultValue the default value if it is not set
 @return a new set of ranges from the configured value]]>
      </doc>
    </method>
    <method name="getStringCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 a collection of <code>String</code>s.  
 If no such property is specified then empty collection is returned.
 <p>
 This is an optimized version of {@link #getStrings(String)}
 
 @param name property name.
 @return property value as a collection of <code>String</code>s.]]>
      </doc>
    </method>
    <method name="getStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s.  
 If no such property is specified then <code>null</code> is returned.
 
 @param name property name.
 @return property value as an array of <code>String</code>s, 
         or <code>null</code>.]]>
      </doc>
    </method>
    <method name="getStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s.  
 If no such property is specified then default value is returned.
 
 @param name property name.
 @param defaultValue The default value
 @return property value as an array of <code>String</code>s, 
         or default value.]]>
      </doc>
    </method>
    <method name="getTrimmedStringCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 a collection of <code>String</code>s, trimmed of the leading and trailing whitespace.  
 If no such property is specified then empty <code>Collection</code> is returned.

 @param name property name.
 @return property value as a collection of <code>String</code>s, or empty <code>Collection</code>]]>
      </doc>
    </method>
    <method name="getTrimmedStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s, trimmed of the leading and trailing whitespace.
 If no such property is specified then an empty array is returned.
 
 @param name property name.
 @return property value as an array of trimmed <code>String</code>s, 
         or empty array.]]>
      </doc>
    </method>
    <method name="getTrimmedStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s, trimmed of the leading and trailing whitespace.
 If no such property is specified then default value is returned.
 
 @param name property name.
 @param defaultValue The default value
 @return property value as an array of trimmed <code>String</code>s, 
         or default value.]]>
      </doc>
    </method>
    <method name="setStrings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set the array of string values for the <code>name</code> property as 
 as comma delimited values.  
 
 @param name property name.
 @param values The values]]>
      </doc>
    </method>
    <method name="getPassword" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the value for a known password configuration element.
 In order to enable the elimination of clear text passwords in config,
 this method attempts to resolve the property name as an alias through
 the CredentialProvider API and conditionally fallsback to config.
 @param name property name
 @return password]]>
      </doc>
    </method>
    <method name="getPasswordFromCredentialProviders" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Try and resolve the provided element name as a credential provider
 alias.
 @param name alias of the provisioned credential
 @return password or null if not found
 @throws IOException]]>
      </doc>
    </method>
    <method name="getPasswordFromConfig" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Fallback to clear text passwords in configuration.
 @param name
 @return clear text password or null]]>
      </doc>
    </method>
    <method name="getSocketAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostProperty" type="java.lang.String"/>
      <param name="addressProperty" type="java.lang.String"/>
      <param name="defaultAddressValue" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Get the socket address for <code>hostProperty</code> as a
 <code>InetSocketAddress</code>. If <code>hostProperty</code> is
 <code>null</code>, <code>addressProperty</code> will be used. This
 is useful for cases where we want to differentiate between host
 bind address and address clients should use to establish connection.

 @param hostProperty bind host property name.
 @param addressProperty address property name.
 @param defaultAddressValue the default value
 @param defaultPort the default port
 @return InetSocketAddress]]>
      </doc>
    </method>
    <method name="getSocketAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultAddress" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Get the socket address for <code>name</code> property as a
 <code>InetSocketAddress</code>.
 @param name property name.
 @param defaultAddress the default value
 @param defaultPort the default port
 @return InetSocketAddress]]>
      </doc>
    </method>
    <method name="setSocketAddr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address for the <code>name</code> property as
 a <code>host:port</code>.]]>
      </doc>
    </method>
    <method name="updateConnectAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostProperty" type="java.lang.String"/>
      <param name="addressProperty" type="java.lang.String"/>
      <param name="defaultAddressValue" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address a client can use to connect for the
 <code>name</code> property as a <code>host:port</code>.  The wildcard
 address is replaced with the local host's address. If the host and address
 properties are configured the host component of the address will be combined
 with the port component of the addr to generate the address.  This is to allow
 optional control over which host name is used in multi-home bind-host
 cases where a host can have multiple names
 @param hostProperty the bind-host configuration name
 @param addressProperty the service address configuration name
 @param defaultAddressValue the service default address configuration value
 @param addr InetSocketAddress of the service listener
 @return InetSocketAddress for clients to connect]]>
      </doc>
    </method>
    <method name="updateConnectAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address a client can use to connect for the
 <code>name</code> property as a <code>host:port</code>.  The wildcard
 address is replaced with the local host's address.
 @param name property name.
 @param addr InetSocketAddress of a listener to store in the given property
 @return InetSocketAddress for clients to connect]]>
      </doc>
    </method>
    <method name="getClassByName" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
      <doc>
      <![CDATA[Load a class by name.
 
 @param name the class name.
 @return the class object.
 @throws ClassNotFoundException if the class is not found.]]>
      </doc>
    </method>
    <method name="getClassByNameOrNull" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Load a class by name, returning null rather than throwing an exception
 if it couldn't be loaded. This is to avoid the overhead of creating
 an exception.
 
 @param name the class name
 @return the class object, or null if it could not be found.]]>
      </doc>
    </method>
    <method name="getClasses" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property
 as an array of <code>Class</code>.
 The value of the property specifies a list of comma separated class names.  
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 @param name the property name.
 @param defaultValue default value.
 @return property value as a <code>Class[]</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Class</code>.  
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 @param name the class name.
 @param defaultValue default value.
 @return property value as a <code>Class</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Class</code>
 implementing the interface specified by <code>xface</code>.
   
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 An exception is thrown if the returned class does not implement the named
 interface. 
 
 @param name the class name.
 @param defaultValue default value.
 @param xface the interface implemented by the named class.
 @return property value as a <code>Class</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getInstances" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>List</code>
 of objects implementing the interface specified by <code>xface</code>.
 
 An exception is thrown if any of the classes does not exist, or if it does
 not implement the named interface.
 
 @param name the property name.
 @param xface the interface implemented by the classes named by
        <code>name</code>.
 @return a <code>List</code> of objects implementing <code>xface</code>.]]>
      </doc>
    </method>
    <method name="setClass"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="theClass" type="java.lang.Class"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to the name of a 
 <code>theClass</code> implementing the given interface <code>xface</code>.
 
 An exception is thrown if <code>theClass</code> does not implement the 
 interface <code>xface</code>. 
 
 @param name property name.
 @param theClass property value.
 @param xface the interface implemented by the named class.]]>
      </doc>
    </method>
    <method name="getLocalPath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirsProp" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a local file under a directory named by <i>dirsProp</i> with
 the given <i>path</i>.  If <i>dirsProp</i> contains multiple directories,
 then one is chosen based on <i>path</i>'s hash code.  If the selected
 directory does not exist, an attempt is made to create it.
 
 @param dirsProp directory in which to locate the file.
 @param path file-path.
 @return local file under the directory with the given path.]]>
      </doc>
    </method>
    <method name="getFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirsProp" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a local file name under a directory named in <i>dirsProp</i> with
 the given <i>path</i>.  If <i>dirsProp</i> contains multiple directories,
 then one is chosen based on <i>path</i>'s hash code.  If the selected
 directory does not exist, an attempt is made to create it.
 
 @param dirsProp directory in which to locate the file.
 @param path file-path.
 @return local file under the directory with the given path.]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the {@link URL} for the named resource.
 
 @param name resource name.
 @return the url for the named resource.]]>
      </doc>
    </method>
    <method name="getConfResourceAsInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get an input stream attached to the configuration resource with the
 given <code>name</code>.
 
 @param name configuration resource name.
 @return an input stream attached to the resource.]]>
      </doc>
    </method>
    <method name="getConfResourceAsReader" return="java.io.Reader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a {@link Reader} attached to the configuration resource with the
 given <code>name</code>.
 
 @param name configuration resource name.
 @return a reader attached to the resource.]]>
      </doc>
    </method>
    <method name="getFinalParameters" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the set of parameters marked final.

 @return final parameter set.]]>
      </doc>
    </method>
    <method name="getProps" return="java.util.Properties"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of keys in the configuration.

 @return number of keys in the configuration.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears all keys from the configuration.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an {@link Iterator} to go through the list of <code>String</code> 
 key-value pairs in the configuration.
 
 @return an iterator over the entries.]]>
      </doc>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write out the non-default properties in this configuration to the given
 {@link OutputStream} using UTF-8 encoding.
 
 @param out the output stream to write to.]]>
      </doc>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write out the non-default properties in this configuration to the given
 {@link Writer}.
 
 @param out the writer to write to.]]>
      </doc>
    </method>
    <method name="dumpConfiguration"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="org.apache.hadoop.conf.Configuration"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes out all the parameters and their properties (final and resource) to
  the given {@link Writer}
  The format of the output would be 
  { "properties" : [ {key1,value1,key1.isFinal,key1.resource}, {key2,value2,
  key2.isFinal,key2.resource}... ] } 
  It does not output the parameters of the configuration object which is 
  loaded from an input stream.
 @param out the Writer to write to
 @throws IOException]]>
      </doc>
    </method>
    <method name="getClassLoader" return="java.lang.ClassLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link ClassLoader} for this job.
 
 @return the correct class loader.]]>
      </doc>
    </method>
    <method name="setClassLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classLoader" type="java.lang.ClassLoader"/>
      <doc>
      <![CDATA[Set the class loader that will be used to load the various objects.
 
 @param classLoader the new class loader.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setQuietMode"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="quietmode" type="boolean"/>
      <doc>
      <![CDATA[Set the quietness-mode. 
 
 In the quiet-mode, error and informational messages might not be logged.
 
 @param quietmode <code>true</code> to set quiet-mode on, <code>false</code>
              to turn it off.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[For debugging.  List non-default properties to the terminal and exit.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getValByRegex" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <doc>
      <![CDATA[get keys matching the the regex 
 @param regex
 @return Map<String,String> with matching keys]]>
      </doc>
    </method>
    <method name="dumpDeprecatedKeys"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasWarnedDeprecation" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether or not a deprecated name has been warned. If the name is not
 deprecated then always return false]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides access to configuration parameters.

 <h4 id="Resources">Resources</h4>

 <p>Configurations are specified by resources. A resource contains a set of
 name/value pairs as XML data. Each resource is named by either a 
 <code>String</code> or by a {@link Path}. If named by a <code>String</code>, 
 then the classpath is examined for a file with that name.  If named by a 
 <code>Path</code>, then the local filesystem is examined directly, without 
 referring to the classpath.

 <p>Unless explicitly turned off, Hadoop by default specifies two 
 resources, loaded in-order from the classpath: <ol>
 <li><tt>
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a></tt>: Read-only defaults for hadoop.</li>
 <li><tt>core-site.xml</tt>: Site-specific configuration for a given hadoop
 installation.</li>
 </ol>
 Applications may add additional resources, which are loaded
 subsequent to these resources in the order they are added.
 
 <h4 id="FinalParams">Final Parameters</h4>

 <p>Configuration parameters may be declared <i>final</i>. 
 Once a resource declares a value final, no subsequently-loaded 
 resource can alter that value.  
 For example, one might define a final parameter with:
 <tt><pre>
  &lt;property&gt;
    &lt;name&gt;dfs.hosts.include&lt;/name&gt;
    &lt;value&gt;/etc/hadoop/conf/hosts.include&lt;/value&gt;
    <b>&lt;final&gt;true&lt;/final&gt;</b>
  &lt;/property&gt;</pre></tt>

 Administrators typically define parameters as final in 
 <tt>core-site.xml</tt> for values that user applications may not alter.

 <h4 id="VariableExpansion">Variable Expansion</h4>

 <p>Value strings are first processed for <i>variable expansion</i>. The
 available properties are:<ol>
 <li>Other properties defined in this Configuration; and, if a name is
 undefined here,</li>
 <li>Properties in {@link System#getProperties()}.</li>
 </ol>

 <p>For example, if a configuration resource contains the following property
 definitions: 
 <tt><pre>
  &lt;property&gt;
    &lt;name&gt;basedir&lt;/name&gt;
    &lt;value&gt;/user/${<i>user.name</i>}&lt;/value&gt;
  &lt;/property&gt;
  
  &lt;property&gt;
    &lt;name&gt;tempdir&lt;/name&gt;
    &lt;value&gt;${<i>basedir</i>}/tmp&lt;/value&gt;
  &lt;/property&gt;</pre></tt>

 When <tt>conf.get("tempdir")</tt> is called, then <tt>${<i>basedir</i>}</tt>
 will be resolved to another property in this Configuration, while
 <tt>${<i>user.name</i>}</tt> would then ordinarily be resolved to the value
 of the System property with that name.
 By default, warnings will be given to any deprecated configuration 
 parameters and these are suppressible by configuring
 <tt>log4j.logger.org.apache.hadoop.conf.Configuration.deprecation</tt> in
 log4j.properties file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configuration -->
  <!-- start class org.apache.hadoop.conf.Configuration.DeprecationDelta -->
  <class name="Configuration.DeprecationDelta" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Configuration.DeprecationDelta" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Configuration.DeprecationDelta" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNewKeys" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCustomMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A pending addition to the global set of deprecated keys.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configuration.DeprecationDelta -->
  <!-- start class org.apache.hadoop.conf.Configuration.IntegerRanges -->
  <class name="Configuration.IntegerRanges" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable"/>
    <constructor name="Configuration.IntegerRanges"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Configuration.IntegerRanges" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isIncluded" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Is the given value in the set of ranges
 @param value the value to check
 @return is the value in the ranges?]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return true if there are no values in this range, else false.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A class that represents a set of positive integer ranges. It parses 
 strings of the form: "2-3,5,7-" where ranges are separated by comma and 
 the lower/upper bounds are separated by dash. Either the lower or upper 
 bound may be omitted meaning all values up to or over. So the string 
 above means 2, 3, 5, and 7, 8, 9, ...]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configuration.IntegerRanges -->
  <!-- start class org.apache.hadoop.conf.Configured -->
  <class name="Configured" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="Configured"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Configured.]]>
      </doc>
    </constructor>
    <constructor name="Configured" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Configured.]]>
      </doc>
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for things that may be configured with a {@link Configuration}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configured -->
  <!-- start class org.apache.hadoop.conf.ConfServlet.BadFormatException -->
  <class name="ConfServlet.BadFormatException" extends="java.lang.Exception"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfServlet.BadFormatException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.conf.ConfServlet.BadFormatException -->
  <!-- start interface org.apache.hadoop.conf.Reconfigurable -->
  <interface name="Reconfigurable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <method name="reconfigureProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <param name="newVal" type="java.lang.String"/>
      <exception name="ReconfigurationException" type="org.apache.hadoop.conf.ReconfigurationException"/>
      <doc>
      <![CDATA[Change a configuration property on this object to the value specified.

 Change a configuration property on this object to the value specified 
 and return the previous value that the configuration property was set to
 (or null if it was not previously set). If newVal is null, set the property
 to its default value;

 If the property cannot be changed, throw a 
 {@link ReconfigurationException}.]]>
      </doc>
    </method>
    <method name="isPropertyReconfigurable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <doc>
      <![CDATA[Return whether a given property is changeable at run time.

 If isPropertyReconfigurable returns true for a property,
 then changeConf should not throw an exception when changing
 this property.]]>
      </doc>
    </method>
    <method name="getReconfigurableProperties" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return all the properties that can be changed at run time.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Something whose {@link Configuration} can be changed at run time.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.conf.Reconfigurable -->
  <!-- start class org.apache.hadoop.conf.ReconfigurableBase -->
  <class name="ReconfigurableBase" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Reconfigurable"/>
    <constructor name="ReconfigurableBase"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a ReconfigurableBase.]]>
      </doc>
    </constructor>
    <constructor name="ReconfigurableBase" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a ReconfigurableBase with the {@link Configuration}
 conf.]]>
      </doc>
    </constructor>
    <method name="setReconfigurationUtil"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ru" type="org.apache.hadoop.conf.ReconfigurationUtil"/>
    </method>
    <method name="getChangedProperties" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newConf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="oldConf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="startReconfigurationTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Start a reconfiguration task to reload configuration in background.]]>
      </doc>
    </method>
    <method name="getReconfigurationTaskStatus" return="org.apache.hadoop.conf.ReconfigurationTaskStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="shutdownReconfigurationTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reconfigureProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <param name="newVal" type="java.lang.String"/>
      <exception name="ReconfigurationException" type="org.apache.hadoop.conf.ReconfigurationException"/>
      <doc>
      <![CDATA[{@inheritDoc}

 This method makes the change to this objects {@link Configuration}
 and calls reconfigurePropertyImpl to update internal data structures.
 This method cannot be overridden, subclasses should instead override
 reconfigureProperty.]]>
      </doc>
    </method>
    <method name="getReconfigurableProperties" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 Subclasses must override this.]]>
      </doc>
    </method>
    <method name="isPropertyReconfigurable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <doc>
      <![CDATA[{@inheritDoc}

 Subclasses may wish to override this with a more efficient implementation.]]>
      </doc>
    </method>
    <method name="reconfigurePropertyImpl"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <param name="newVal" type="java.lang.String"/>
      <exception name="ReconfigurationException" type="org.apache.hadoop.conf.ReconfigurationException"/>
      <doc>
      <![CDATA[Change a configuration property.

 Subclasses must override this. This method applies the change to
 all internal data structures derived from the configuration property
 that is being changed. If this object owns other Reconfigurable objects
 reconfigureProperty should be called recursively to make sure that
 to make sure that the configuration of these objects is updated.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility base class for implementing the Reconfigurable interface.

 Subclasses should override reconfigurePropertyImpl to change individual
 properties and getReconfigurableProperties to get all properties that
 can be changed at run time.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurableBase -->
  <!-- start class org.apache.hadoop.conf.ReconfigurationException -->
  <class name="ReconfigurationException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReconfigurationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of {@link ReconfigurationException}.]]>
      </doc>
    </constructor>
    <constructor name="ReconfigurationException" type="java.lang.String, java.lang.String, java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of {@link ReconfigurationException}.]]>
      </doc>
    </constructor>
    <constructor name="ReconfigurationException" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of {@link ReconfigurationException}.]]>
      </doc>
    </constructor>
    <method name="getProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get property that cannot be changed.]]>
      </doc>
    </method>
    <method name="getNewValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get value to which property was supposed to be changed.]]>
      </doc>
    </method>
    <method name="getOldValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get old value of property that cannot be changed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Exception indicating that configuration property cannot be changed
 at run time.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurationException -->
  <!-- start class org.apache.hadoop.conf.ReconfigurationServlet -->
  <class name="ReconfigurationServlet" extends="javax.servlet.http.HttpServlet"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReconfigurationServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
    <method name="doGet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="javax.servlet.http.HttpServletRequest"/>
      <param name="resp" type="javax.servlet.http.HttpServletResponse"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="doPost"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="javax.servlet.http.HttpServletRequest"/>
      <param name="resp" type="javax.servlet.http.HttpServletResponse"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="CONF_SERVLET_RECONFIGURABLE_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A servlet for changing a node's configuration.

 Reloads the configuration file, verifies whether changes are
 possible and asks the admin to approve the change.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurationServlet -->
  <!-- start class org.apache.hadoop.conf.ReconfigurationTaskStatus -->
  <class name="ReconfigurationTaskStatus" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReconfigurationTaskStatus" type="long, long, java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hasTask" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if
   - A reconfiguration task has finished or
   - an active reconfiguration task is running]]>
      </doc>
    </method>
    <method name="stopped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if the latest reconfiguration task has finished and there is
 no another active task running.]]>
      </doc>
    </method>
    <method name="getStartTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEndTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStatus" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurationTaskStatus -->
  <!-- start class org.apache.hadoop.conf.ReconfigurationUtil -->
  <class name="ReconfigurationUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReconfigurationUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getChangedProperties" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newConf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="oldConf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="parseChangedProperties" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newConf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="oldConf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurationUtil -->
  <!-- start class org.apache.hadoop.conf.ReconfigurationUtil.PropertyChange -->
  <class name="ReconfigurationUtil.PropertyChange" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReconfigurationUtil.PropertyChange" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="prop" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="oldVal" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="newVal" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurationUtil.PropertyChange -->
  <doc>
  <![CDATA[Configuration of system parameters.]]>
  </doc>
</package>
<package name="org.apache.hadoop.crypto">
</package>
<package name="org.apache.hadoop.crypto.key">
  <!-- start class org.apache.hadoop.crypto.key.CachingKeyProvider -->
  <class name="CachingKeyProvider" extends="org.apache.hadoop.crypto.key.KeyProviderExtension"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CachingKeyProvider" type="org.apache.hadoop.crypto.key.KeyProvider, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCurrentKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKeyVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="deleteKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A <code>KeyProviderExtension</code> implementation providing a short lived
 cache for <code>KeyVersions</code> and <code>Metadata</code>to avoid burst
 of requests to hit the underlying <code>KeyProvider</code>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.CachingKeyProvider -->
  <!-- start class org.apache.hadoop.crypto.key.JavaKeyStoreProvider.Factory -->
  <class name="JavaKeyStoreProvider.Factory" extends="org.apache.hadoop.crypto.key.KeyProviderFactory"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JavaKeyStoreProvider.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[The factory to create JksProviders, which is used by the ServiceLoader.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.JavaKeyStoreProvider.Factory -->
  <!-- start class org.apache.hadoop.crypto.key.JavaKeyStoreProvider.KeyMetadata -->
  <class name="JavaKeyStoreProvider.KeyMetadata" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.security.Key"/>
    <implements name="java.io.Serializable"/>
    <method name="getAlgorithm" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFormat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEncoded" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An adapter between a KeyStore Key and our Metadata. This is used to store
 the metadata in a KeyStore even though isn't really a key.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.JavaKeyStoreProvider.KeyMetadata -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProvider -->
  <class name="KeyProvider" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProvider" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 
 @param conf configuration for the provider]]>
      </doc>
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the provider configuration.
 
 @return the provider configuration]]>
      </doc>
    </method>
    <method name="options" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[A helper function to create an options object.
 @param conf the configuration to use
 @return a new options object]]>
      </doc>
    </method>
    <method name="isTransient" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this provider represents a store
 that is intended for transient use - such as the UserProvider
 is. These providers are generally used to provide access to
 keying material rather than for long term storage.
 @return true if transient, false otherwise]]>
      </doc>
    </method>
    <method name="getKeyVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key material for a specific version of the key. This method is used
 when decrypting data.
 @param versionName the name of a specific version of the key
 @return the key material
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKeys" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key names for all keys.
 @return the list of key names
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKeysMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get key metadata in bulk.
 @param names the names of the keys to get
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKeyVersions" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key material for all versions of a specific key name.
 @return the list of key material
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCurrentKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the current version of the key, which should be used for encrypting new
 data.
 @param name the base name of the key
 @return the version name of the current version of the key or null if the
    key version doesn't exist
 @throws IOException]]>
      </doc>
    </method>
    <method name="getMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get metadata about the key.
 @param name the basename of the key
 @return the key's metadata or null if the key doesn't exist
 @throws IOException]]>
      </doc>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new key. The given key must not already exist.
 @param name the base name of the key
 @param material the key material for the first version of the key.
 @param options the options for the new key.
 @return the version name of the first version of the key.
 @throws IOException]]>
      </doc>
    </method>
    <method name="generateKey" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <param name="algorithm" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <doc>
      <![CDATA[Generates a key material.

 @param size length of the key.
 @param algorithm algorithm to use for generating the key.
 @return the generated key.
 @throws NoSuchAlgorithmException]]>
      </doc>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new key generating the material for it.
 The given key must not already exist.
 <p/>
 This implementation generates the key material and calls the
 {@link #createKey(String, byte[], Options)} method.

 @param name the base name of the key
 @param options the options for the new key.
 @return the version name of the first version of the key.
 @throws IOException
 @throws NoSuchAlgorithmException]]>
      </doc>
    </method>
    <method name="deleteKey"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete the given key.
 @param name the name of the key to delete
 @throws IOException]]>
      </doc>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Roll a new version of the given key.
 @param name the basename of the key
 @param material the new key material
 @return the name of the new version of the key
 @throws IOException]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Can be used by implementing classes to close any resources
 that require closing]]>
      </doc>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Roll a new version of the given key generating the material for it.
 <p/>
 This implementation generates the key material and calls the
 {@link #rollNewVersion(String, byte[])} method.

 @param name the basename of the key
 @return the name of the new version of the key
 @throws IOException]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Ensures that any changes to the keys are written to persistent store.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getBaseName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Split the versionName in to a base name. Converts "/aaa/bbb/3" to
 "/aaa/bbb".
 @param versionName the version name to split
 @return the base name of the key
 @throws IOException]]>
      </doc>
    </method>
    <method name="buildVersionName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="version" type="int"/>
      <doc>
      <![CDATA[Build a version string from a basename and version number. Converts
 "/aaa/bbb" and 3 to "/aaa/bbb@3".
 @param name the basename of the key
 @param version the version of the key
 @return the versionName of the key.]]>
      </doc>
    </method>
    <method name="findProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerList" type="java.util.List"/>
      <param name="keyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Find the provider with the given key.
 @param providerList the list of providers
 @param keyName the key name we are looking for
 @return the KeyProvider that has the key]]>
      </doc>
    </method>
    <field name="DEFAULT_CIPHER_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_CIPHER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BITLENGTH_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BITLENGTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A provider of secret key material for Hadoop applications. Provides an
 abstraction to separate key storage from users of encryption. It
 is intended to support getting or storing keys in a variety of ways,
 including third party bindings.
 <P/>
 <code>KeyProvider</code> implementations must be thread safe.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProvider -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProvider.KeyVersion -->
  <class name="KeyProvider.KeyVersion" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProvider.KeyVersion" type="java.lang.String, java.lang.String, byte[]"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVersionName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaterial" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The combination of both the key version name and the key material.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProvider.KeyVersion -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProvider.Metadata -->
  <class name="KeyProvider.Metadata" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProvider.Metadata" type="java.lang.String, int, java.lang.String, java.util.Map, java.util.Date, int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="KeyProvider.Metadata" type="byte[]"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize a new metadata object from a set of bytes.
 @param bytes the serialized metadata
 @throws IOException]]>
      </doc>
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCreated" return="java.util.Date"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCipher" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAlgorithm" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the algorithm from the cipher.
 @return the algorithm name]]>
      </doc>
    </method>
    <method name="getBitLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVersions" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addVersion" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="serialize" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize the metadata to a set of bytes.
 @return the serialized bytes
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Key metadata that is associated with the key.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProvider.Metadata -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProvider.Options -->
  <class name="KeyProvider.Options" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProvider.Options" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setCipher" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cipher" type="java.lang.String"/>
    </method>
    <method name="setBitLength" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bitLength" type="int"/>
    </method>
    <method name="setDescription" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="description" type="java.lang.String"/>
    </method>
    <method name="setAttributes" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributes" type="java.util.Map"/>
    </method>
    <method name="getCipher" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBitLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Options when creating key objects.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProvider.Options -->
  <!-- start interface org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.CryptoExtension -->
  <interface name="KeyProviderCryptoExtension.CryptoExtension"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.crypto.key.KeyProviderExtension.Extension"/>
    <method name="warmUpEncryptedKeys"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyNames" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Calls to this method allows the underlying KeyProvider to warm-up any
 implementation specific caches used to store the Encrypted Keys.
 @param keyNames Array of Key Names]]>
      </doc>
    </method>
    <method name="drain"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyName" type="java.lang.String"/>
      <doc>
      <![CDATA[Drains the Queue for the provided key.

 @param keyName the key to drain the Queue for]]>
      </doc>
    </method>
    <method name="generateEncryptedKey" return="org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encryptionKeyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Generates a key material and encrypts it using the given key version name
 and initialization vector. The generated key material is of the same
 length as the <code>KeyVersion</code> material of the latest key version
 of the key and is encrypted using the same cipher.
 <p/>
 NOTE: The generated key is not stored by the <code>KeyProvider</code>

 @param encryptionKeyName
          The latest KeyVersion of this key's material will be encrypted.
 @return EncryptedKeyVersion with the generated key material, the version
         name is 'EEK' (for Encrypted Encryption Key)
 @throws IOException
           thrown if the key material could not be generated
 @throws GeneralSecurityException
           thrown if the key material could not be encrypted because of a
           cryptographic issue.]]>
      </doc>
    </method>
    <method name="decryptEncryptedKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encryptedKeyVersion" type="org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Decrypts an encrypted byte[] key material using the given a key version
 name and initialization vector.

 @param encryptedKeyVersion
          contains keyVersionName and IV to decrypt the encrypted key
          material
 @return a KeyVersion with the decrypted key material, the version name is
         'EK' (For Encryption Key)
 @throws IOException
           thrown if the key material could not be decrypted
 @throws GeneralSecurityException
           thrown if the key material could not be decrypted because of a
           cryptographic issue.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[CryptoExtension is a type of Extension that exposes methods to generate
 EncryptedKeys and to decrypt the same.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.CryptoExtension -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion -->
  <class name="KeyProviderCryptoExtension.EncryptedKeyVersion" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProviderCryptoExtension.EncryptedKeyVersion" type="java.lang.String, java.lang.String, byte[], org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new EncryptedKeyVersion.

 @param keyName                  Name of the encryption key used to
                                 encrypt the encrypted key.
 @param encryptionKeyVersionName Version name of the encryption key used
                                 to encrypt the encrypted key.
 @param encryptedKeyIv           Initialization vector of the encrypted
                                 key. The IV of the encryption key used to
                                 encrypt the encrypted key is derived from
                                 this IV.
 @param encryptedKeyVersion      The encrypted encryption key version.]]>
      </doc>
    </constructor>
    <method name="createForDecryption" return="org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyName" type="java.lang.String"/>
      <param name="encryptionKeyVersionName" type="java.lang.String"/>
      <param name="encryptedKeyIv" type="byte[]"/>
      <param name="encryptedKeyMaterial" type="byte[]"/>
      <doc>
      <![CDATA[Factory method to create a new EncryptedKeyVersion that can then be
 passed into {@link #decryptEncryptedKey}. Note that the fields of the
 returned EncryptedKeyVersion will only partially be populated; it is not
 necessarily suitable for operations besides decryption.

 @param keyName Key name of the encryption key use to encrypt the
                encrypted key.
 @param encryptionKeyVersionName Version name of the encryption key used
                                 to encrypt the encrypted key.
 @param encryptedKeyIv           Initialization vector of the encrypted
                                 key. The IV of the encryption key used to
                                 encrypt the encrypted key is derived from
                                 this IV.
 @param encryptedKeyMaterial     Key material of the encrypted key.
 @return EncryptedKeyVersion suitable for decryption.]]>
      </doc>
    </method>
    <method name="getEncryptionKeyName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Name of the encryption key used to encrypt the encrypted key.]]>
      </doc>
    </method>
    <method name="getEncryptionKeyVersionName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Version name of the encryption key used to encrypt the encrypted
 key.]]>
      </doc>
    </method>
    <method name="getEncryptedKeyIv" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Initialization vector of the encrypted key. The IV of the
 encryption key used to encrypt the encrypted key is derived from this
 IV.]]>
      </doc>
    </method>
    <method name="getEncryptedKeyVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The encrypted encryption key version.]]>
      </doc>
    </method>
    <method name="deriveIV" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="encryptedKeyIV" type="byte[]"/>
      <doc>
      <![CDATA[Derive the initialization vector (IV) for the encryption key from the IV
 of the encrypted key. This derived IV is used with the encryption key to
 decrypt the encrypted key.
 <p/>
 The alternative to this is using the same IV for both the encryption key
 and the encrypted key. Even a simple symmetric transformation like this
 improves security by avoiding IV re-use. IVs will also be fairly unique
 among different EEKs.

 @param encryptedKeyIV of the encrypted key (i.e. {@link
 #getEncryptedKeyIv()})
 @return IV for the encryption key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An encrypted encryption key (EEK) and related information. An EEK must be
 decrypted using the key's encryption key before it can be used.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProviderDelegationTokenExtension -->
  <class name="KeyProviderDelegationTokenExtension" extends="org.apache.hadoop.crypto.key.KeyProviderExtension"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addDelegationTokens" return="org.apache.hadoop.security.token.Token[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="java.lang.String"/>
      <param name="credentials" type="org.apache.hadoop.security.Credentials"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Passes the renewer and Credentials object to the underlying
 {@link DelegationTokenExtension}
 @param renewer the user allowed to renew the delegation tokens
 @param credentials cache in which to add new delegation tokens
 @return list of new delegation tokens
 @throws IOException thrown if IOException if an IO error occurs.]]>
      </doc>
    </method>
    <method name="createKeyProviderDelegationTokenExtension" return="org.apache.hadoop.crypto.key.KeyProviderDelegationTokenExtension"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyProvider" type="org.apache.hadoop.crypto.key.KeyProvider"/>
      <doc>
      <![CDATA[Creates a <code>KeyProviderDelegationTokenExtension</code> using a given
 {@link KeyProvider}.
 <p/>
 If the given <code>KeyProvider</code> implements the
 {@link DelegationTokenExtension} interface the <code>KeyProvider</code>
 itself will provide the extension functionality, otherwise a default
 extension implementation will be used.

 @param keyProvider <code>KeyProvider</code> to use to create the
 <code>KeyProviderDelegationTokenExtension</code> extension.
 @return a <code>KeyProviderDelegationTokenExtension</code> instance
 using the given <code>KeyProvider</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A KeyProvider extension with the ability to add a renewer's Delegation
 Tokens to the provided Credentials.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProviderDelegationTokenExtension -->
  <!-- start interface org.apache.hadoop.crypto.key.KeyProviderDelegationTokenExtension.DelegationTokenExtension -->
  <interface name="KeyProviderDelegationTokenExtension.DelegationTokenExtension"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.crypto.key.KeyProviderExtension.Extension"/>
    <method name="addDelegationTokens" return="org.apache.hadoop.security.token.Token[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="java.lang.String"/>
      <param name="credentials" type="org.apache.hadoop.security.Credentials"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The implementer of this class will take a renewer and add all
 delegation tokens associated with the renewer to the
 <code>Credentials</code> object if it is not already present,
 @param renewer the user allowed to renew the delegation tokens
 @param credentials cache in which to add new delegation tokens
 @return list of new delegation tokens
 @throws IOException thrown if IOException if an IO error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[DelegationTokenExtension is a type of Extension that exposes methods to
 needed to work with Delegation Tokens.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.crypto.key.KeyProviderDelegationTokenExtension.DelegationTokenExtension -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProviderExtension -->
  <class name="KeyProviderExtension" extends="org.apache.hadoop.crypto.key.KeyProvider"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProviderExtension" type="org.apache.hadoop.crypto.key.KeyProvider, E"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExtension" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getKeyProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="isTransient" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeysMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCurrentKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKeyVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKeys" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKeyVersions" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="deleteKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is a utility class used to extend the functionality of KeyProvider, that
 takes a KeyProvider and an Extension. It implements all the required methods
 of the KeyProvider by delegating it to the provided KeyProvider.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProviderExtension -->
  <!-- start interface org.apache.hadoop.crypto.key.KeyProviderExtension.Extension -->
  <interface name="KeyProviderExtension.Extension"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[A marker interface for the KeyProviderExtension subclass implement.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.crypto.key.KeyProviderExtension.Extension -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProviderFactory -->
  <class name="KeyProviderFactory" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProviderFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getProviders" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="get" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a KeyProvider based on a provided URI.

 @param uri key provider URI
 @param conf configuration to initialize the key provider
 @return the key provider for the specified URI, or <code>NULL</code> if
         a provider for the specified URI scheme could not be found.
 @throws IOException thrown if the provider failed to initialize.]]>
      </doc>
    </method>
    <field name="KEY_PROVIDER_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A factory to create a list of KeyProvider based on the path given in a
 Configuration. It uses a service loader interface to find the available
 KeyProviders and create them based on the list of URIs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProviderFactory -->
  <!-- start class org.apache.hadoop.crypto.key.KeyShell -->
  <class name="KeyShell" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.Tool"/>
    <constructor name="KeyShell"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Primary entry point for the KeyShell; called via main().

 @param args Command line arguments.
 @return 0 on success and 1 on failure.  This value is passed back to
 the unix shell, so we must follow shell return code conventions:
 the return code is an unsigned character, and 0 means success, and
 small positive integers mean failure.
 @throws Exception]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[main() entry point for the KeyShell.  While strictly speaking the
 return is void, it will System.exit() with a return code: 0 is for
 success and 1 for failure.

 @param args Command line arguments.
 @throws Exception]]>
      </doc>
    </method>
    <field name="out" type="java.io.PrintStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[allows stdout to be captured if necessary]]>
      </doc>
    </field>
    <field name="err" type="java.io.PrintStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[allows stderr to be captured if necessary]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This program is the CLI utility for the KeyProvider facilities in Hadoop.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyShell -->
  <!-- start class org.apache.hadoop.crypto.key.UserProvider.Factory -->
  <class name="UserProvider.Factory" extends="org.apache.hadoop.crypto.key.KeyProviderFactory"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UserProvider.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.UserProvider.Factory -->
</package>
<package name="org.apache.hadoop.crypto.key.kms">
  <!-- start class org.apache.hadoop.crypto.key.kms.KMSClientProvider.Factory -->
  <class name="KMSClientProvider.Factory" extends="org.apache.hadoop.crypto.key.KeyProviderFactory"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KMSClientProvider.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[The factory to create KMSClientProvider, which is used by the
 ServiceLoader.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.kms.KMSClientProvider.Factory -->
  <!-- start class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSEncryptedKeyVersion -->
  <class name="KMSClientProvider.KMSEncryptedKeyVersion" extends="org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KMSClientProvider.KMSEncryptedKeyVersion" type="java.lang.String, java.lang.String, byte[], java.lang.String, byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSEncryptedKeyVersion -->
  <!-- start class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSKeyVersion -->
  <class name="KMSClientProvider.KMSKeyVersion" extends="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KMSClientProvider.KMSKeyVersion" type="java.lang.String, java.lang.String, byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSKeyVersion -->
  <!-- start class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSMetadata -->
  <class name="KMSClientProvider.KMSMetadata" extends="org.apache.hadoop.crypto.key.KeyProvider.Metadata"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KMSClientProvider.KMSMetadata" type="java.lang.String, int, java.lang.String, java.util.Map, java.util.Date, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSMetadata -->
  <!-- start interface org.apache.hadoop.crypto.key.kms.ValueQueue.QueueRefiller -->
  <interface name="ValueQueue.QueueRefiller"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fillQueueForKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyName" type="java.lang.String"/>
      <param name="keyQueue" type="java.util.Queue"/>
      <param name="numValues" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Method that has to be implemented by implementing classes to fill the
 Queue.
 @param keyName Key name
 @param keyQueue Queue that needs to be filled
 @param numValues number of Values to be added to the queue.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[QueueRefiller interface a client must implement to use this class]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.crypto.key.kms.ValueQueue.QueueRefiller -->
  <!-- start class org.apache.hadoop.crypto.key.kms.ValueQueue.SyncGenerationPolicy -->
  <class name="ValueQueue.SyncGenerationPolicy" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.crypto.key.kms.ValueQueue.SyncGenerationPolicy[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.crypto.key.kms.ValueQueue.SyncGenerationPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Policy to decide how many values to return to client when client asks for
 "n" values and Queue is empty.
 This decides how many values to return when client calls "getAtMost"]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.kms.ValueQueue.SyncGenerationPolicy -->
</package>
<package name="org.apache.hadoop.crypto.random">
</package>
<package name="org.apache.hadoop.fs">
  <!-- start class org.apache.hadoop.fs.AbstractFileSystem -->
  <class name="AbstractFileSystem" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractFileSystem" type="java.net.URI, java.lang.String, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="URISyntaxException" type="java.net.URISyntaxException"/>
      <doc>
      <![CDATA[Constructor to be called by subclasses.
 
 @param uri for this file system.
 @param supportedScheme the scheme supported by the implementor
 @param authorityNeeded if true then theURI must have authority, if false
          then the URI must have null authority.

 @throws URISyntaxException <code>uri</code> has syntax error]]>
      </doc>
    </constructor>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isValidName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if the specified string is considered valid in the path part
 of a URI by this file system.  The default implementation enforces the rules
 of HDFS, but subclasses may override this method to implement specific
 validation rules for specific file systems.
 
 @param src String source filename to check, path part of the URI
 @return boolean true if the specified string is considered valid]]>
      </doc>
    </method>
    <method name="createFileSystem" return="org.apache.hadoop.fs.AbstractFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a file system instance for the specified uri using the conf. The
 conf is used to find the class name that implements the file system. The
 conf is also passed to the file system for its configuration.

 @param uri URI of the file system
 @param conf Configuration for the file system
 
 @return Returns the file system for the given URI

 @throws UnsupportedFileSystemException file system for <code>uri</code> is
           not found]]>
      </doc>
    </method>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Get the statistics for a particular file system.
 
 @param uri
          used as key to lookup STATISTICS_TABLE. Only scheme and authority
          part of the uri are used.
 @return a statistics object]]>
      </doc>
    </method>
    <method name="clearStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="printStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prints statistics for all file systems.]]>
      </doc>
    </method>
    <method name="getAllStatistics" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="org.apache.hadoop.fs.AbstractFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[The main factory method for creating a file system. Get a file system for
 the URI's scheme and authority. The scheme of the <code>uri</code>
 determines a configuration property name,
 <tt>fs.AbstractFileSystem.<i>scheme</i>.impl</tt> whose value names the
 AbstractFileSystem class.
 
 The entire URI and conf is passed to the AbstractFileSystem factory method.
 
 @param uri for the file system to be created.
 @param conf which is passed to the file system impl.
 
 @return file system for the given URI.
 
 @throws UnsupportedFileSystemException if the file system for
           <code>uri</code> is not supported.]]>
      </doc>
    </method>
    <method name="checkScheme"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="supportedScheme" type="java.lang.String"/>
      <doc>
      <![CDATA[Check that the Uri's scheme matches
 @param uri
 @param supportedScheme]]>
      </doc>
    </method>
    <method name="getUriDefaultPort" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The default port of this file system.
 
 @return default port of this file system's Uri scheme
         A uri with a port of -1 => default port;]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a URI whose scheme and authority identify this FileSystem.
 
 @return the uri of this file system.]]>
      </doc>
    </method>
    <method name="checkPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Check that a Path belongs to this FileSystem.
 
 If the path is fully qualified URI, then its scheme and authority
 matches that of this file system. Otherwise the path must be 
 slash-relative name.
 
 @throws InvalidPathException if the path is invalid]]>
      </doc>
    </method>
    <method name="getUriPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Get the path-part of a pathname. Checks that URI matches this file system
 and that the path-part is a valid name.
 
 @param p path
 
 @return path-part of the Path p]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Make the path fully qualified to this file system
 @param path
 @return the qualified path]]>
      </doc>
    </method>
    <method name="getInitialWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Some file systems like LocalFileSystem have an initial workingDir
 that is used as the starting workingDir. For other file systems
 like HDFS there is no built in notion of an initial workingDir.
 
 @return the initial workingDir if the file system has such a notion
         otherwise return a null.]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the current user's home directory in this file system.
 The default implementation returns "/user/$USER/".
 
 @return current user's home directory.]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a set of server default configuration values.
 
 @return server default configuration values
 
 @throws IOException an I/O error occurred]]>
      </doc>
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the fully-qualified path of path f resolving the path
 through any internal symlinks or mount point
 @param p path to be resolved
 @return fully qualified path 
 @throws FileNotFoundException, AccessControlException, IOException
         UnresolvedLinkException if symbolic link on path cannot be resolved
          internally]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="createFlag" type="java.util.EnumSet"/>
      <param name="opts" type="org.apache.hadoop.fs.Options.CreateOpts[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#create(Path, EnumSet, Options.CreateOpts...)} except
 that the Path f must be fully qualified and the permission is absolute
 (i.e. umask has been applied).]]>
      </doc>
    </method>
    <method name="createInternal" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="flag" type="java.util.EnumSet"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link #create(Path, EnumSet, Options.CreateOpts...)} except that the opts
 have been declared explicitly.]]>
      </doc>
    </method>
    <method name="mkdir"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#mkdir(Path, FsPermission, boolean)} except that the Path
 f must be fully qualified and the permission is absolute (i.e. 
 umask has been applied).]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#delete(Path, boolean)} except that Path f must be for
 this file system.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#open(Path)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#open(Path, int)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="setReplication" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setReplication(Path, short)} except that Path f must be
 for this file system.]]>
      </doc>
    </method>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="options" type="org.apache.hadoop.fs.Options.Rename[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system.]]>
      </doc>
    </method>
    <method name="renameInternal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system and NO OVERWRITE is performed.
 
 File systems that do not have a built in overwrite need implement only this
 method and can take advantage of the default impl of the other
 {@link #renameInternal(Path, Path, boolean)}]]>
      </doc>
    </method>
    <method name="renameInternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system.]]>
      </doc>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the file system supports symlinks, false otherwise.
 @return true if filesystem supports symlinks]]>
      </doc>
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <doc>
      <![CDATA[The specification of this method matches that of  
 {@link FileContext#createSymlink(Path, Path, boolean)};]]>
      </doc>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Partially resolves the path. This is used during symlink resolution in
 {@link FSLinkResolver}, and differs from the similarly named method
 {@link FileContext#getLinkTarget(Path)}.
 @throws IOException subclass implementations may throw IOException]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setPermission(Path, FsPermission)} except that Path f
 must be for this file system.]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setOwner(Path, String, String)} except that Path f must
 be for this file system.]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setTimes(Path, long, long)} except that Path f must be
 for this file system.]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileChecksum(Path)} except that Path f must be for
 this file system.]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileStatus(Path)} 
 except that an UnresolvedLinkException may be thrown if a symlink is 
 encountered in the path.]]>
      </doc>
    </method>
    <method name="access"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="mode" type="org.apache.hadoop.fs.permission.FsAction"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#access(Path, FsAction)}
 except that an UnresolvedLinkException may be thrown if a symlink is
 encountered in the path.]]>
      </doc>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileLinkStatus(Path)}
 except that an UnresolvedLinkException may be thrown if a symlink is  
 encountered in the path leading up to the final path component.
 If the file system does not support symlinks then the behavior is
 equivalent to {@link AbstractFileSystem#getFileStatus(Path)}.]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileBlockLocations(Path, long, long)} except that
 Path f must be for this file system.]]>
      </doc>
    </method>
    <method name="getFsStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFsStatus(Path)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="getFsStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFsStatus(Path)}.]]>
      </doc>
    </method>
    <method name="listStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#listStatus(Path)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#listLocatedStatus(Path)} except that Path f 
 must be for this file system.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext.Util#listStatus(Path)} except that Path f must be 
 for this file system.]]>
      </doc>
    </method>
    <method name="listCorruptFileBlocks" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return an iterator over the corrupt files under the given path
 (may contain duplicates if a file has more than one corrupt block)
 @throws IOException]]>
      </doc>
    </method>
    <method name="setVerifyChecksum"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setVerifyChecksum(boolean, Path)} except that Path f
 must be for this file system.]]>
      </doc>
    </method>
    <method name="getCanonicalServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a canonical name for this file system.
 @return a URI string that uniquely identifies this file system]]>
      </doc>
    </method>
    <method name="getDelegationTokens" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get one or more delegation tokens associated with the filesystem. Normally
 a file system returns a single delegation token. A file system that manages
 multiple file systems underneath, could return set of delegation tokens for
 all the file systems it manages
 
 @param renewer the account name that is allowed to renew the token.
 @return List of delegation tokens.
   If delegation tokens not supported then return a list of size zero.
 @throws IOException]]>
      </doc>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Modifies ACL entries of files and directories.  This method can add new ACL
 entries or modify the permissions on existing ACL entries.  All existing
 ACL entries that are not specified in this call are retained without
 changes.  (Modifications are merged into the current ACL.)

 @param path Path to modify
 @param aclSpec List<AclEntry> describing modifications
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes ACL entries from files and directories.  Other ACL entries are
 retained.

 @param path Path to modify
 @param aclSpec List<AclEntry> describing entries to remove
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all default ACL entries from files and directories.

 @param path Path to modify
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all but the base ACL entries of files and directories.  The entries
 for user, group, and others are retained for compatibility with permission
 bits.

 @param path Path to modify
 @throws IOException if an ACL could not be removed]]>
      </doc>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully replaces ACL of files and directories, discarding all existing
 entries.

 @param path Path to modify
 @param aclSpec List<AclEntry> describing modifications, must include entries
   for user, group, and others for compatibility with permission bits.
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the ACLs of files and directories.

 @param path Path to get
 @return RemoteIterator<AclStatus> which returns each AclStatus
 @throws IOException if an ACL could not be read]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @param flag xattr set flag
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get an xattr for a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attribute
 @param name xattr name.
 @return byte[] xattr value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return Map<String, byte[]> describing the XAttrs of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @param names XAttr names.
 @return Map<String, byte[]> describing the XAttrs of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattr names for a file or directory.
 Only the xattr names for which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return Map<String, byte[]> describing the XAttrs of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Remove an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to remove extended attribute
 @param name xattr name
 @throws IOException]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <field name="statistics" type="org.apache.hadoop.fs.FileSystem.Statistics"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The statistics for this file system.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This class provides an interface for implementors of a Hadoop file system
 (analogous to the VFS of Unix). Applications do not access this class;
 instead they access files across all file systems using {@link FileContext}.
 
 Pathnames passed to AbstractFileSystem can be fully qualified URI that
 matches the "this" file system (ie same scheme and authority) 
 or a Slash-relative name that is assumed to be relative
 to the root of the "this" file system .]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.AbstractFileSystem -->
  <!-- start class org.apache.hadoop.fs.AvroFSInput -->
  <class name="AvroFSInput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <implements name="org.apache.avro.file.SeekableInput"/>
    <constructor name="AvroFSInput" type="org.apache.hadoop.fs.FSDataInputStream, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct given an {@link FSDataInputStream} and its length.]]>
      </doc>
    </constructor>
    <constructor name="AvroFSInput" type="org.apache.hadoop.fs.FileContext, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct given a {@link FileContext} and a {@link Path}.]]>
      </doc>
    </constructor>
    <method name="length" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="seek"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="tell" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Adapts an {@link FSDataInputStream} to Avro's SeekableInput interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.AvroFSInput -->
  <!-- start class org.apache.hadoop.fs.BatchedRemoteIterator -->
  <class name="BatchedRemoteIterator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.RemoteIterator"/>
    <constructor name="BatchedRemoteIterator" type="K"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="makeRequest" return="org.apache.hadoop.fs.BatchedRemoteIterator.BatchedEntries"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prevKey" type="K"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Perform the actual remote request.
 
 @param prevKey The key to send.
 @return A list of replies.]]>
      </doc>
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="elementToPrevKey" return="K"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Return the next list key associated with an element.]]>
      </doc>
    </method>
    <method name="next" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A RemoteIterator that fetches elements in batches.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.BatchedRemoteIterator -->
  <!-- start interface org.apache.hadoop.fs.BatchedRemoteIterator.BatchedEntries -->
  <interface name="BatchedRemoteIterator.BatchedEntries"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasMore" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.BatchedRemoteIterator.BatchedEntries -->
  <!-- start class org.apache.hadoop.fs.BatchedRemoteIterator.BatchedListEntries -->
  <class name="BatchedRemoteIterator.BatchedListEntries" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.BatchedRemoteIterator.BatchedEntries"/>
    <constructor name="BatchedRemoteIterator.BatchedListEntries" type="java.util.List, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasMore" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.BatchedRemoteIterator.BatchedListEntries -->
  <!-- start class org.apache.hadoop.fs.BlockLocation -->
  <class name="BlockLocation" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockLocation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default Constructor]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="org.apache.hadoop.fs.BlockLocation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, offset and length]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, offset, length and corrupt flag]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, network topology, offset and length]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, network topology, offset, length 
 and corrupt flag]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHosts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of hosts (hostname) hosting this block]]>
      </doc>
    </method>
    <method name="getCachedHosts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the list of hosts (hostname) hosting a cached replica of the block]]>
      </doc>
    </method>
    <method name="getNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of names (IP:xferPort) hosting this block]]>
      </doc>
    </method>
    <method name="getTopologyPaths" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of network topology paths for each of the hosts.
 The last component of the path is the "name" (IP:xferPort).]]>
      </doc>
    </method>
    <method name="getOffset" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the start offset of file associated with this block]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the length of the block]]>
      </doc>
    </method>
    <method name="isCorrupt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the corrupt flag.]]>
      </doc>
    </method>
    <method name="setOffset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="long"/>
      <doc>
      <![CDATA[Set the start offset of file associated with this block]]>
      </doc>
    </method>
    <method name="setLength"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="long"/>
      <doc>
      <![CDATA[Set the length of block]]>
      </doc>
    </method>
    <method name="setCorrupt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="corrupt" type="boolean"/>
      <doc>
      <![CDATA[Set the corrupt flag.]]>
      </doc>
    </method>
    <method name="setHosts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hosts" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the hosts hosting this block]]>
      </doc>
    </method>
    <method name="setCachedHosts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cachedHosts" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set the hosts hosting a cached replica of this block]]>
      </doc>
    </method>
    <method name="setNames"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the names (host:port) hosting this block]]>
      </doc>
    </method>
    <method name="setTopologyPaths"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="topologyPaths" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the network topology paths of the hosts]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the network location of a block, information about the hosts
 that contain block replicas, and other block metadata (E.g. the file
 offset associated with the block, length, whether it is corrupt, etc).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.BlockLocation -->
  <!-- start interface org.apache.hadoop.fs.ByteBufferReadable -->
  <interface name="ByteBufferReadable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads up to buf.remaining() bytes into buf. Callers should use
 buf.limit(..) to control the size of the desired read.
 <p/>
 After a successful call, buf.position() and buf.limit() should be
 unchanged, and therefore any data can be immediately read from buf.
 buf.mark() may be cleared or updated.
 <p/>
 In the case of an exception, the values of buf.position() and buf.limit()
 are undefined, and callers should be prepared to recover from this
 eventuality.
 <p/>
 Many implementations will throw {@link UnsupportedOperationException}, so
 callers that are not confident in support for this method from the
 underlying filesystem should be prepared to handle that exception.
 <p/>
 Implementations should treat 0-length requests as legitimate, and must not
 signal an error upon their receipt.

 @param buf
          the ByteBuffer to receive the results of the read operation. Up to
          buf.limit() - buf.position() bytes may be read.
 @return the number of bytes available to read from buf
 @throws IOException
           if there is some error performing the read]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementers of this interface provide a read API that writes to a
 ByteBuffer, not a byte[].]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.ByteBufferReadable -->
  <!-- start interface org.apache.hadoop.fs.CanSetDropBehind -->
  <interface name="CanSetDropBehind"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setDropBehind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dropCache" type="java.lang.Boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Configure whether the stream should drop the cache.

 @param dropCache     Whether to drop the cache.  null means to use the
                      default value.
 @throws IOException  If there was an error changing the dropBehind
                      setting.
         UnsupportedOperationException  If this stream doesn't support
                                        setting the drop-behind.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.CanSetDropBehind -->
  <!-- start interface org.apache.hadoop.fs.CanSetReadahead -->
  <interface name="CanSetReadahead"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setReadahead"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readahead" type="java.lang.Long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Set the readahead on this stream.

 @param readahead     The readahead to use.  null means to use the default.
 @throws IOException  If there was an error changing the dropBehind
                      setting.
         UnsupportedOperationException  If this stream doesn't support
                                        setting readahead.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.CanSetReadahead -->
  <!-- start class org.apache.hadoop.fs.ChecksumException -->
  <class name="ChecksumException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChecksumException" type="java.lang.String, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown for checksum errors.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ChecksumException -->
  <!-- start class org.apache.hadoop.fs.ChecksumFileSystem -->
  <class name="ChecksumFileSystem" extends="org.apache.hadoop.fs.FilterFileSystem"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChecksumFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getApproxChkSumLength" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="long"/>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <doc>
      <![CDATA[Set whether to verify checksum.]]>
      </doc>
    </method>
    <method name="setWriteChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeChecksum" type="boolean"/>
    </method>
    <method name="getRawFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the raw file system]]>
      </doc>
    </method>
    <method name="getChecksumFile" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return the name of the checksum file associated with a file.]]>
      </doc>
    </method>
    <method name="isChecksumFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return true iff file is a checksum file name.]]>
      </doc>
    </method>
    <method name="getChecksumFileLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="fileSize" type="long"/>
      <doc>
      <![CDATA[Return the length of the checksum file given the size of the 
 actual file.]]>
      </doc>
    </method>
    <method name="getBytesPerSum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the bytes Per Checksum]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getChecksumLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="long"/>
      <param name="bytesPerSum" type="int"/>
      <doc>
      <![CDATA[Calculated the length of the checksum file in bytes.
 @param size the length of the data file in bytes
 @param bytesPerSum the number of bytes in a checksum block
 @return the number of bytes in the checksum file]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 Implement the abstract <tt>setReplication</tt> of <tt>FileSystem</tt>
 @param src file name
 @param replication new replication
 @throws IOException
 @return true if successful;
         false if file does not exist or is a directory]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Rename files/dirs]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Implement the delete(Path, boolean) in checksum
 file system.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 
 @param f
          given path
 @return the statuses of the files/directories in the given path
 @throws IOException]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 
 @param f
          given path
 @return the statuses of the files/directories in the given patch
 @throws IOException]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="copyCrc" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 If src and dst are directories, the copyCrc parameter
 determines whether to copy CRC files.]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reportChecksumFailure" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="in" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="inPos" type="long"/>
      <param name="sums" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="sumsPos" type="long"/>
      <doc>
      <![CDATA[Report a checksum error to the file system.
 @param f the file name containing the error
 @param in the stream open on the file
 @param inPos the position of the beginning of the bad data in the file
 @param sums the stream open on the checksum file
 @param sumsPos the position of the beginning of the bad data in the checksum file
 @return if retry is neccessary]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract Checksumed FileSystem.
 It provide a basic implementation of a Checksumed FileSystem,
 which creates a checksum file for each raw file.
 It generates & verifies checksums at the client side.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ChecksumFileSystem -->
  <!-- start class org.apache.hadoop.fs.CommonConfigurationKeysPublic -->
  <class name="CommonConfigurationKeysPublic" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CommonConfigurationKeysPublic"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="IO_NATIVE_LIB_AVAILABLE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_NATIVE_LIB_AVAILABLE_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_NATIVE_LIB_AVAILABLE_KEY]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY]]>
      </doc>
    </field>
    <field name="FS_DEFAULT_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DEFAULT_NAME_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DEFAULT_NAME_KEY]]>
      </doc>
    </field>
    <field name="FS_DF_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DF_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DF_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_DU_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DU_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DU_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_TABLE_MAPPING_FILE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_DEPENDENCY_SCRIPT_FILE_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_TRASH_CHECKPOINT_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_CHECKPOINT_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_TRASH_CHECKPOINT_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_LOCAL_BLOCK_SIZE_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Not used anywhere, looks like default value for FS_LOCAL_BLOCK_SIZE]]>
      </doc>
    </field>
    <field name="FS_AUTOMATIC_CLOSE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_AUTOMATIC_CLOSE_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_AUTOMATIC_CLOSE_KEY]]>
      </doc>
    </field>
    <field name="FS_FILE_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_FTP_HOST_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_FTP_HOST_PORT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_TRASH_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAPFILE_BLOOM_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_ERROR_RATE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_ERROR_RATE_DEFAULT" type="float"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAPFILE_BLOOM_ERROR_RATE_KEY]]>
      </doc>
    </field>
    <field name="IO_COMPRESSION_CODEC_LZO_CLASS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Codec class that implements Lzo compression algorithm]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_INTERVAL_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAP_INDEX_INTERVAL_DEFAULT]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_SKIP_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_SKIP_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAP_INDEX_SKIP_KEY]]>
      </doc>
    </field>
    <field name="IO_SEQFILE_COMPRESS_BLOCKSIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_SEQFILE_COMPRESS_BLOCKSIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SEQFILE_COMPRESS_BLOCKSIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_FILE_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_FILE_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_FILE_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_SKIP_CHECKSUM_ERRORS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_SKIP_CHECKSUM_ERRORS_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SKIP_CHECKSUM_ERRORS_KEY]]>
      </doc>
    </field>
    <field name="IO_SORT_MB_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Moved to mapreduce, see mapreduce.task.io.sort.mb
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801">
      <doc>
      <![CDATA[@deprecated Moved to mapreduce, see mapreduce.task.io.sort.mb
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801]]>
      </doc>
    </field>
    <field name="IO_SORT_MB_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SORT_MB_DEFAULT]]>
      </doc>
    </field>
    <field name="IO_SORT_FACTOR_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Moved to mapreduce, see mapreduce.task.io.sort.factor
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801">
      <doc>
      <![CDATA[@deprecated Moved to mapreduce, see mapreduce.task.io.sort.factor
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801]]>
      </doc>
    </field>
    <field name="IO_SORT_FACTOR_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SORT_FACTOR_DEFAULT]]>
      </doc>
    </field>
    <field name="IO_SERIALIZATIONS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_IO_CHUNK_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_IO_CHUNK_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_IO_CHUNK_SIZE_DEFAULT]]>
      </doc>
    </field>
    <field name="TFILE_FS_INPUT_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_FS_INPUT_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_FS_INPUT_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="TFILE_FS_OUTPUT_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_FS_OUTPUT_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_FS_OUTPUT_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECTION_MAXIDLETIME_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_TIMEOUT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_TIMEOUT_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_TIMEOUT_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_MAX_RETRIES_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_RETRY_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_RETRY_INTERVAL_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_RETRY_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_TCPNODELAY_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_TCPNODELAY_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for IPC_CLIENT_TCPNODELAY_KEY]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LISTEN_QUEUE_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LISTEN_QUEUE_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_LISTEN_QUEUE_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_KILL_MAX_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_KILL_MAX_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_KILL_MAX_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_IDLETHRESHOLD_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_IDLETHRESHOLD_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_IDLETHRESHOLD_DEFAULT]]>
      </doc>
    </field>
    <field name="IPC_SERVER_TCPNODELAY_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_TCPNODELAY_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_TCPNODELAY_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_RPC_SOCKET_FACTORY_CLASS_DEFAULT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_RPC_SOCKET_FACTORY_CLASS_DEFAULT_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SOCKS_SERVER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_UTIL_HASH_TYPE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_UTIL_HASH_TYPE_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for HADOOP_UTIL_HASH_TYPE_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_MAPPING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_SECS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_SECS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_NEGATIVE_CACHE_SECS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_NEGATIVE_CACHE_SECS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_WARN_AFTER_MS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_WARN_AFTER_MS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_AUTHENTICATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTHORIZATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_INSTRUMENTATION_REQUIRES_ADMIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SERVICE_USER_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTH_TO_LOCAL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SSL_ENABLED_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SSL_ENABLED_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HTTP_POLICY_HTTP_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HTTP_POLICY_HTTPS_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_RPC_PROTECTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SASL_PROPS_RESOLVER_CLASS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Class to override Sasl Properties for a connection]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_KEY_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CIPHER_SUITE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CIPHER_SUITE_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_JCE_PROVIDER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_IMPERSONATION_PROVIDER_CLASS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Class to override Impersonation provider]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_SIZE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for KMS_CLIENT_ENC_KEY_CACHE_SIZE]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_LOW_WATERMARK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field nam