<html>
<body>
<table border="1">
<tr>
<td>name</td><td>value</td><td>description</td>
</tr>
<tr>
<td><a name="hadoop.common.configuration.version">hadoop.common.configuration.version</a></td><td>3.0.0</td><td>version of this configuration file</td>
</tr>
<tr>
<td><a name="hadoop.tmp.dir">hadoop.tmp.dir</a></td><td>/tmp/hadoop-${user.name}</td><td>A base for other temporary directories.</td>
</tr>
<tr>
<td><a name="hadoop.http.filter.initializers">hadoop.http.filter.initializers</a></td><td>org.apache.hadoop.http.lib.StaticUserWebFilter</td><td>A comma separated list of class names. Each class in the list
  must extend org.apache.hadoop.http.FilterInitializer. The corresponding
  Filter will be initialized. Then, the Filter will be applied to all user
  facing jsp and servlet web pages.  The ordering of the list defines the
  ordering of the filters.</td>
</tr>
<tr>
<td><a name="hadoop.security.authorization">hadoop.security.authorization</a></td><td>false</td><td>Is service-level authorization enabled?</td>
</tr>
<tr>
<td><a name="hadoop.security.instrumentation.requires.admin">hadoop.security.instrumentation.requires.admin</a></td><td>false</td><td>
    Indicates if administrator ACLs are required to access
    instrumentation servlets (JMX, METRICS, CONF, STACKS).
  </td>
</tr>
<tr>
<td><a name="hadoop.security.authentication">hadoop.security.authentication</a></td><td>simple</td><td>Possible values are simple (no authentication), and kerberos
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping">hadoop.security.group.mapping</a></td><td>org.apache.hadoop.security.JniBasedUnixGroupsMappingWithFallback</td><td>
    Class for user to group mapping (get groups for a given user) for ACL.
    The default implementation,
    org.apache.hadoop.security.JniBasedUnixGroupsMappingWithFallback,
    will determine if the Java Native Interface (JNI) is available. If JNI is
    available the implementation will use the API within hadoop to resolve a
    list of groups for a user. If JNI is not available then the shell
    implementation, ShellBasedUnixGroupsMapping, is used.  This implementation
    shells out to the Linux/Unix environment with the
    bash -c groups command to resolve a list of groups for a user.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.dns.interface">hadoop.security.dns.interface</a></td><td></td><td>
    The name of the Network Interface from which the service should determine
    its host name for Kerberos login. e.g. eth2. In a multi-homed environment,
    the setting can be used to affect the _HOST substitution in the service
    Kerberos principal. If this configuration value is not set, the service
    will use its default hostname as returned by
    InetAddress.getLocalHost().getCanonicalHostName().

    Most clusters will not require this setting.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.dns.nameserver">hadoop.security.dns.nameserver</a></td><td></td><td>
    The host name or IP address of the name server (DNS) which a service Node
    should use to determine its own host name for Kerberos Login. Requires
    hadoop.security.dns.interface.

    Most clusters will not require this setting.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.dns.log-slow-lookups.enabled">hadoop.security.dns.log-slow-lookups.enabled</a></td><td>false</td><td>
    Time name lookups (via SecurityUtil) and log them if they exceed the
    configured threshold.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.dns.log-slow-lookups.threshold.ms">hadoop.security.dns.log-slow-lookups.threshold.ms</a></td><td>1000</td><td>
    If slow lookup logging is enabled, this threshold is used to decide if a
    lookup is considered slow enough to be logged.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.groups.cache.secs">hadoop.security.groups.cache.secs</a></td><td>300</td><td>
    This is the config controlling the validity of the entries in the cache
    containing the user-&gt;group mapping. When this duration has expired,
    then the implementation of the group mapping provider is invoked to get
    the groups of the user and then cached back.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.groups.negative-cache.secs">hadoop.security.groups.negative-cache.secs</a></td><td>30</td><td>
    Expiration time for entries in the the negative user-to-group mapping
    caching, in seconds. This is useful when invalid users are retrying
    frequently. It is suggested to set a small value for this expiration, since
    a transient error in group lookup could temporarily lock out a legitimate
    user.

    Set this to zero or negative value to disable negative user-to-group caching.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.groups.cache.warn.after.ms">hadoop.security.groups.cache.warn.after.ms</a></td><td>5000</td><td>
    If looking up a single user to group takes longer than this amount of
    milliseconds, we will log a warning message.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.groups.cache.background.reload">hadoop.security.groups.cache.background.reload</a></td><td>false</td><td>
    Whether to reload expired user-&gt;group mappings using a background thread
    pool. If set to true, a pool of
    hadoop.security.groups.cache.background.reload.threads is created to
    update the cache in the background.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.groups.cache.background.reload.threads">hadoop.security.groups.cache.background.reload.threads</a></td><td>3</td><td>
    Only relevant if hadoop.security.groups.cache.background.reload is true.
    Controls the number of concurrent background user-&gt;group cache entry
    refreshes. Pending refresh requests beyond this value are queued and
    processed when a thread is free.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.groups.shell.command.timeout">hadoop.security.groups.shell.command.timeout</a></td><td>0s</td><td>
    Used by the ShellBasedUnixGroupsMapping class, this property controls how
    long to wait for the underlying shell command that is run to fetch groups.
    Expressed in seconds (e.g. 10s, 1m, etc.), if the running command takes
    longer than the value configured, the command is aborted and the groups
    resolver would return a result of no groups found. A value of 0s (default)
    would mean an infinite wait (i.e. wait until the command exits on its own).
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.connection.timeout.ms">hadoop.security.group.mapping.ldap.connection.timeout.ms</a></td><td>60000</td><td>
    This property is the connection timeout (in milliseconds) for LDAP
    operations. If the LDAP provider doesn't establish a connection within the
    specified period, it will abort the connect attempt. Non-positive value
    means no LDAP connection timeout is specified in which case it waits for the
    connection to establish until the underlying network times out.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.read.timeout.ms">hadoop.security.group.mapping.ldap.read.timeout.ms</a></td><td>60000</td><td>
    This property is the read timeout (in milliseconds) for LDAP
    operations. If the LDAP provider doesn't get a LDAP response within the
    specified period, it will abort the read attempt. Non-positive value
    means no read timeout is specified in which case it waits for the response
    infinitely.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.num.attempts">hadoop.security.group.mapping.ldap.num.attempts</a></td><td>3</td><td>
    This property is the number of attempts to be made for LDAP operations.
    If this limit is exceeded, LdapGroupsMapping will return an empty
    group list.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.num.attempts.before.failover">hadoop.security.group.mapping.ldap.num.attempts.before.failover</a></td><td>3</td><td>
    This property is the number of attempts to be made for LDAP operations
    using a single LDAP instance. If multiple LDAP servers are configured
    and this number of failed operations is reached, we will switch to the
    next LDAP server. The configuration for the overall number of attempts
    will still be respected, failover will thus be performed only if this
    property is less than hadoop.security.group.mapping.ldap.num.attempts.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.url">hadoop.security.group.mapping.ldap.url</a></td><td></td><td>
    The URL of the LDAP server(s) to use for resolving user groups when using
    the LdapGroupsMapping user to group mapping. Supports configuring multiple
    LDAP servers via a comma-separated list.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.ssl">hadoop.security.group.mapping.ldap.ssl</a></td><td>false</td><td>
    Whether or not to use SSL when connecting to the LDAP server.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.ssl.keystore">hadoop.security.group.mapping.ldap.ssl.keystore</a></td><td></td><td>
    File path to the SSL keystore that contains the SSL certificate required
    by the LDAP server.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.ssl.keystore.password.file">hadoop.security.group.mapping.ldap.ssl.keystore.password.file</a></td><td></td><td>
    The path to a file containing the password of the LDAP SSL keystore. If
    the password is not configured in credential providers and the property
    hadoop.security.group.mapping.ldap.ssl.keystore.password is not set,
    LDAPGroupsMapping reads password from the file.

    IMPORTANT: This file should be readable only by the Unix user running
    the daemons and should be a local file.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.ssl.keystore.password">hadoop.security.group.mapping.ldap.ssl.keystore.password</a></td><td></td><td>
    The password of the LDAP SSL keystore. this property name is used as an
    alias to get the password from credential providers. If the password can
    not be found and hadoop.security.credential.clear-text-fallback is true
    LDAPGroupsMapping uses the value of this property for password.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.conversion.rule">hadoop.security.group.mapping.ldap.conversion.rule</a></td><td>none</td><td>
    The rule is applied on the group names received from LDAP when
    RuleBasedLdapGroupsMapping is configured.
    Supported rules are "to_upper", "to_lower" and "none".
    to_upper: This will convert all the group names to uppercase.
    to_lower: This will convert all the group names to lowercase.
    none: This will retain the source formatting, this is default value.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.credential.clear-text-fallback">hadoop.security.credential.clear-text-fallback</a></td><td>true</td><td>
    true or false to indicate whether or not to fall back to storing credential
    password as clear text. The default value is true. This property only works
    when the password can't not be found from credential providers.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.credential.provider.path">hadoop.security.credential.provider.path</a></td><td></td><td>
    A comma-separated list of URLs that indicates the type and
    location of a list of providers that should be consulted.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.credstore.java-keystore-provider.password-file">hadoop.security.credstore.java-keystore-provider.password-file</a></td><td></td><td>
    The path to a file containing the custom password for all keystores
    that may be configured in the provider path.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.ssl.truststore">hadoop.security.group.mapping.ldap.ssl.truststore</a></td><td></td><td>
    File path to the SSL truststore that contains the root certificate used to
    sign the LDAP server's certificate. Specify this if the LDAP server's
    certificate is not signed by a well known certificate authority.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.ssl.truststore.password.file">hadoop.security.group.mapping.ldap.ssl.truststore.password.file</a></td><td></td><td>
    The path to a file containing the password of the LDAP SSL truststore.

    IMPORTANT: This file should be readable only by the Unix user running
    the daemons.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.bind.users">hadoop.security.group.mapping.ldap.bind.users</a></td><td></td><td>
    Aliases of users to be used to bind as when connecting to the LDAP
    server(s). Each alias will have to have its distinguished name and
    password specified through:
    hadoop.security.group.mapping.ldap.bind.user
    and a password configuration such as:
    hadoop.security.group.mapping.ldap.bind.password.alias

    For example, if:
    hadoop.security.group.mapping.ldap.bind.users=alias1,alias2

    then the following configuration is valid:
    hadoop.security.group.mapping.ldap.bind.users.alias1.bind.user=bindUser1
    hadoop.security.group.mapping.ldap.bind.users.alias1.bind.password.alias=
    bindPasswordAlias1
    hadoop.security.group.mapping.ldap.bind.users.alias2.bind.user=bindUser2
    hadoop.security.group.mapping.ldap.bind.users.alias2.bind.password.alias=
    bindPasswordAlias2
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.bind.user">hadoop.security.group.mapping.ldap.bind.user</a></td><td></td><td>
    The distinguished name of the user to bind as when connecting to the LDAP
    server. This may be left blank if the LDAP server supports anonymous binds.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.bind.password.alias">hadoop.security.group.mapping.ldap.bind.password.alias</a></td><td></td><td>
    The alias of the bind user to be used to get the password from credential
    providers. If the alias is empty, property
    hadoop.security.group.mapping.ldap.bind.password is used instead.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.bind.password.file">hadoop.security.group.mapping.ldap.bind.password.file</a></td><td></td><td>
    The path to a file containing the password of the bind user. If
    the password is not configured in credential providers and the property
    hadoop.security.group.mapping.ldap.bind.password is not set,
    LDAPGroupsMapping reads password from the file.

    IMPORTANT: This file should be readable only by the Unix user running
    the daemons and should be a local file.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.bind.password">hadoop.security.group.mapping.ldap.bind.password</a></td><td></td><td>
    The password of the bind user. this property name is used as an
    alias to get the password from credential providers. If the password can
    not be found and hadoop.security.credential.clear-text-fallback is true
    LDAPGroupsMapping uses the value of this property for password.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.base">hadoop.security.group.mapping.ldap.base</a></td><td></td><td>
    The search base for the LDAP connection. This is a distinguished name,
    and will typically be the root of the LDAP directory.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.userbase">hadoop.security.group.mapping.ldap.userbase</a></td><td></td><td>
    The search base for the LDAP connection for user search query. This is a
    distinguished name, and its the root of the LDAP directory for users.
    If not set, hadoop.security.group.mapping.ldap.base is used.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.groupbase">hadoop.security.group.mapping.ldap.groupbase</a></td><td></td><td>
    The search base for the LDAP connection for group search . This is a
    distinguished name, and its the root of the LDAP directory for groups.
    If not set, hadoop.security.group.mapping.ldap.base is used.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.search.filter.user">hadoop.security.group.mapping.ldap.search.filter.user</a></td><td>(&amp;(objectClass=user)(sAMAccountName={0}))</td><td>
    An additional filter to use when searching for LDAP users. The default will
    usually be appropriate for Active Directory installations. If connecting to
    an LDAP server with a non-AD schema, this should be replaced with
    (&amp;(objectClass=inetOrgPerson)(uid={0}). {0} is a special string used to
    denote where the username fits into the filter.

    If the LDAP server supports posixGroups, Hadoop can enable the feature by
    setting the value of this property to "posixAccount" and the value of
    the hadoop.security.group.mapping.ldap.search.filter.group property to
    "posixGroup".
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.search.filter.group">hadoop.security.group.mapping.ldap.search.filter.group</a></td><td>(objectClass=group)</td><td>
    An additional filter to use when searching for LDAP groups. This should be
    changed when resolving groups against a non-Active Directory installation.

    See the description of hadoop.security.group.mapping.ldap.search.filter.user
    to enable posixGroups support.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.search.attr.memberof">hadoop.security.group.mapping.ldap.search.attr.memberof</a></td><td></td><td>
      The attribute of the user object that identifies its group objects. By
      default, Hadoop makes two LDAP queries per user if this value is empty. If
      set, Hadoop will attempt to resolve group names from this attribute,
      instead of making the second LDAP query to get group objects. The value
      should be 'memberOf' for an MS AD installation.
    </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.search.attr.member">hadoop.security.group.mapping.ldap.search.attr.member</a></td><td>member</td><td>
    The attribute of the group object that identifies the users that are
    members of the group. The default will usually be appropriate for
    any LDAP installation.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.search.attr.group.name">hadoop.security.group.mapping.ldap.search.attr.group.name</a></td><td>cn</td><td>
    The attribute of the group object that identifies the group name. The
    default will usually be appropriate for all LDAP systems.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.search.group.hierarchy.levels">hadoop.security.group.mapping.ldap.search.group.hierarchy.levels</a></td><td>0</td><td>
    The number of levels to go up the group hierarchy when determining
    which groups a user is part of. 0 Will represent checking just the
    group that the user belongs to.  Each additional level will raise the
    time it takes to execute a query by at most
    hadoop.security.group.mapping.ldap.directory.search.timeout.
    The default will usually be appropriate for all LDAP systems.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.posix.attr.uid.name">hadoop.security.group.mapping.ldap.posix.attr.uid.name</a></td><td>uidNumber</td><td>
    The attribute of posixAccount to use when groups for membership.
    Mostly useful for schemas wherein groups have memberUids that use an
    attribute other than uidNumber.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.posix.attr.gid.name">hadoop.security.group.mapping.ldap.posix.attr.gid.name</a></td><td>gidNumber</td><td>
    The attribute of posixAccount indicating the group id.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.ldap.directory.search.timeout">hadoop.security.group.mapping.ldap.directory.search.timeout</a></td><td>10000</td><td>
    The attribute applied to the LDAP SearchControl properties to set a
    maximum time limit when searching and awaiting a result.
    Set to 0 if infinite wait period is desired.
    Default is 10 seconds. Units in milliseconds.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.providers">hadoop.security.group.mapping.providers</a></td><td></td><td>
    Comma separated of names of other providers to provide user to group
    mapping. Used by CompositeGroupsMapping.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.group.mapping.providers.combined">hadoop.security.group.mapping.providers.combined</a></td><td>true</td><td>
    true or false to indicate whether groups from the providers are combined or
    not. The default value is true. If true, then all the providers will be
    tried to get groups and all the groups are combined to return as the final
    results. Otherwise, providers are tried one by one in the configured list
    order, and if any groups are retrieved from any provider, then the groups
    will be returned without trying the left ones.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.service.user.name.key">hadoop.security.service.user.name.key</a></td><td></td><td>
    For those cases where the same RPC protocol is implemented by multiple
    servers, this configuration is required for specifying the principal
    name to use for the service when the client wishes to make an RPC call.
  </td>
</tr>
<tr>
<td><a name="fs.azure.user.agent.prefix">fs.azure.user.agent.prefix</a></td><td>unknown</td><td>
      WASB passes User-Agent header to the Azure back-end. The default value
      contains WASB version, Java Runtime version, Azure Client library version,
      and the value of the configuration option fs.azure.user.agent.prefix.
    </td>
</tr>
<tr>
<td><a name="hadoop.security.uid.cache.secs">hadoop.security.uid.cache.secs</a></td><td>14400</td><td>
        This is the config controlling the validity of the entries in the cache
        containing the userId to userName and groupId to groupName used by
        NativeIO getFstat().
    </td>
</tr>
<tr>
<td><a name="hadoop.service.shutdown.timeout">hadoop.service.shutdown.timeout</a></td><td>30s</td><td>
      Timeout to wait for each shutdown operation to complete.
      If a hook takes longer than this time to complete, it will be interrupted,
      so the service will shutdown. This allows the service shutdown
      to recover from a blocked operation.
      Some shutdown hooks may need more time than this, for example when
      a large amount of data needs to be uploaded to an object store.
      In this situation: increase the timeout.

      The minimum duration of the timeout is 1 second, "1s".
    </td>
</tr>
<tr>
<td><a name="hadoop.rpc.protection">hadoop.rpc.protection</a></td><td>authentication</td><td>A comma-separated list of protection values for secured sasl
      connections. Possible values are authentication, integrity and privacy.
      authentication means authentication only and no integrity or privacy;
      integrity implies authentication and integrity are enabled; and privacy
      implies all of authentication, integrity and privacy are enabled.
      hadoop.security.saslproperties.resolver.class can be used to override
      the hadoop.rpc.protection for a connection at the server side.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.saslproperties.resolver.class">hadoop.security.saslproperties.resolver.class</a></td><td></td><td>SaslPropertiesResolver used to resolve the QOP used for a
      connection. If not specified, the full set of values specified in
      hadoop.rpc.protection is used while determining the QOP used for the
      connection. If a class is specified, then the QOP values returned by
      the class will be used while determining the QOP used for the connection.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.sensitive-config-keys">hadoop.security.sensitive-config-keys</a></td><td>
      secret$
      password$
      ssl.keystore.pass$
      fs.s3a.server-side-encryption.key
      fs.s3a.*.server-side-encryption.key
      fs.s3a.secret.key
      fs.s3a.*.secret.key
      fs.s3a.session.key
      fs.s3a.*.session.key
      fs.s3a.session.token
      fs.s3a.*.session.token
      fs.azure.account.key.*
      fs.azure.oauth2.*
      fs.adl.oauth2.*
      credential$
      oauth.*secret
      oauth.*password
      oauth.*token
      hadoop.security.sensitive-config-keys
  </td><td>A comma-separated or multi-line list of regular expressions to
      match configuration keys that should be redacted where appropriate, for
      example, when logging modified properties during a reconfiguration,
      private credentials should not be logged.
  </td>
</tr>
<tr>
<td><a name="hadoop.workaround.non.threadsafe.getpwuid">hadoop.workaround.non.threadsafe.getpwuid</a></td><td>true</td><td>Some operating systems or authentication modules are known to
  have broken implementations of getpwuid_r and getpwgid_r, such that these
  calls are not thread-safe. Symptoms of this problem include JVM crashes
  with a stack trace inside these functions. If your system exhibits this
  issue, enable this configuration parameter to include a lock around the
  calls as a workaround.

  An incomplete list of some systems known to have this issue is available
  at http://wiki.apache.org/hadoop/KnownBrokenPwuidImplementations
  </td>
</tr>
<tr>
<td><a name="hadoop.kerberos.kinit.command">hadoop.kerberos.kinit.command</a></td><td>kinit</td><td>Used to periodically renew Kerberos credentials when provided
  to Hadoop. The default setting assumes that kinit is in the PATH of users
  running the Hadoop client. Change this to the absolute path to kinit if this
  is not the case.
  </td>
</tr>
<tr>
<td><a name="hadoop.kerberos.min.seconds.before.relogin">hadoop.kerberos.min.seconds.before.relogin</a></td><td>60</td><td>The minimum time between relogin attempts for Kerberos, in
    seconds.
    </td>
</tr>
<tr>
<td><a name="hadoop.kerberos.keytab.login.autorenewal.enabled">hadoop.kerberos.keytab.login.autorenewal.enabled</a></td><td>false</td><td>Used to enable automatic renewal of keytab based kerberos login.
    By default the automatic renewal is disabled for keytab based kerberos login.
  </td>
</tr>
<tr>
<td><a name="hadoop.security.auth_to_local">hadoop.security.auth_to_local</a></td><td></td><td>Maps kerberos principals to local user names</td>
</tr>
<tr>
<td><a name="hadoop.security.auth_to_local.mechanism">hadoop.security.auth_to_local.mechanism</a></td><td>hadoop</td><td>The mechanism by which auth_to_local rules are evaluated.
    If set to 'hadoop' it will not allow resulting local user names to have
    either '@' or '/'. If set to 'MIT' it will follow MIT evaluation rules
    and the restrictions of 'hadoop' do not apply.</td>
</tr>
<tr>
<td><a name="hadoop.token.files">hadoop.token.files</a></td><td></td><td>List of token cache files that have delegation tokens for hadoop service</td>
</tr>
<tr>
<td><a name="io.file.buffer.size">io.file.buffer.size</a></td><td>4096</td><td>The size of buffer for use in sequence files.
  The size of this buffer should probably be a multiple of hardware
  page size (4096 on Intel x86), and it determines how much data is
  buffered during read and write operations.</td>
</tr>
<tr>
<td><a name="io.bytes.per.checksum">io.bytes.per.checksum</a></td><td>512</td><td>The number of bytes per checksum.  Must not be larger than
  io.file.buffer.size.</td>
</tr>
<tr>
<td><a name="io.skip.checksum.errors">io.skip.checksum.errors</a></td><td>false</td><td>If true, when a checksum error is encountered while
  reading a sequence file, entries are skipped, instead of throwing an
  exception.</td>
</tr>
<tr>
<td><a name="io.compression.codecs">io.compression.codecs</a></td><td></td><td>A comma-separated list of the compression codec classes that can
  be used for compression/decompression. In addition to any classes specified
  with this property (which take precedence), codec classes on the classpath
  are discovered using a Java ServiceLoader.</td>
</tr>
<tr>
<td><a name="io.compression.codec.bzip2.library">io.compression.codec.bzip2.library</a></td><td>system-native</td><td>The native-code library to be used for compression and
  decompression by the bzip2 codec.  This library could be specified
  either by by name or the full pathname.  In the former case, the
  library is located by the dynamic linker, usually searching the
  directories specified in the environment variable LD_LIBRARY_PATH.

  The value of "system-native" indicates that the default system
  library should be used.  To indicate that the algorithm should
  operate entirely in Java, specify "java-builtin".</td>
</tr>
<tr>
<td><a name="io.serializations">io.serializations</a></td><td>org.apache.hadoop.io.serializer.WritableSerialization, org.apache.hadoop.io.serializer.avro.AvroSpecificSerialization, org.apache.hadoop.io.serializer.avro.AvroReflectSerialization</td><td>A list of serialization classes that can be used for
  obtaining serializers and deserializers.</td>
</tr>
<tr>
<td><a name="io.seqfile.local.dir">io.seqfile.local.dir</a></td><td>${hadoop.tmp.dir}/io/local</td><td>The local directory where sequence file stores intermediate
  data files during merge.  May be a comma-separated list of
  directories on different devices in order to spread disk i/o.
  Directories that do not exist are ignored.
  </td>
</tr>
<tr>
<td><a name="io.map.index.skip">io.map.index.skip</a></td><td>0</td><td>Number of index entries to skip between each entry.
  Zero by default. Setting this to values larger than zero can
  facilitate opening large MapFiles using less memory.</td>
</tr>
<tr>
<td><a name="io.map.index.interval">io.map.index.interval</a></td><td>128</td><td>
    MapFile consist of two files - data file (tuples) and index file
    (keys). For every io.map.index.interval records written in the
    data file, an entry (record-key, data-file-position) is written
    in the index file. This is to allow for doing binary search later
    within the index file to look up records by their keys and get their
    closest positions in the data file.
  </td>
</tr>
<tr>
<td><a name="io.erasurecode.codec.rs.rawcoders">io.erasurecode.codec.rs.rawcoders</a></td><td>rs_native,rs_java</td><td>
    Comma separated raw coder implementations for the rs codec. The earlier
    factory is prior to followings in case of failure of creating raw coders.
  </td>
</tr>
<tr>
<td><a name="io.erasurecode.codec.rs-legacy.rawcoders">io.erasurecode.codec.rs-legacy.rawcoders</a></td><td>rs-legacy_java</td><td>
    Comma separated raw coder implementations for the rs-legacy codec. The earlier
    factory is prior to followings in case of failure of creating raw coders.
  </td>
</tr>
<tr>
<td><a name="io.erasurecode.codec.xor.rawcoders">io.erasurecode.codec.xor.rawcoders</a></td><td>xor_native,xor_java</td><td>
    Comma separated raw coder implementations for the xor codec. The earlier
    factory is prior to followings in case of failure of creating raw coders.
  </td>
</tr>
<tr>
<td><a name="fs.defaultFS">fs.defaultFS</a></td><td>file:///</td><td>The name of the default file system.  A URI whose
  scheme and authority determine the FileSystem implementation.  The
  uri's scheme determines the config property (fs.SCHEME.impl) naming
  the FileSystem implementation class.  The uri's authority is used to
  determine the host, port, etc. for a filesystem.</td>
</tr>
<tr>
<td><a name="fs.default.name">fs.default.name</a></td><td>file:///</td><td>Deprecated. Use (fs.defaultFS) property
  instead</td>
</tr>
<tr>
<td><a name="fs.trash.interval">fs.trash.interval</a></td><td>0</td><td>Number of minutes after which the checkpoint
  gets deleted.  If zero, the trash feature is disabled.
  This option may be configured both on the server and the
  client. If trash is disabled server side then the client
  side configuration is checked. If trash is enabled on the
  server side then the value configured on the server is
  used and the client configuration value is ignored.
  </td>
</tr>
<tr>
<td><a name="fs.trash.checkpoint.interval">fs.trash.checkpoint.interval</a></td><td>0</td><td>Number of minutes between trash checkpoints.
  Should be smaller or equal to fs.trash.interval. If zero,
  the value is set to the value of fs.trash.interval.
  Every time the checkpointer runs it creates a new checkpoint
  out of current and removes checkpoints created more than
  fs.trash.interval minutes ago.
  </td>
</tr>
<tr>
<td><a name="fs.protected.directories">fs.protected.directories</a></td><td></td><td>A comma-separated list of directories which cannot
    be deleted or renamed even by the superuser unless they are empty. This
    setting can be used to guard important system directories
    against accidental deletion due to administrator error.
  </td>
</tr>
<tr>
<td><a name="fs.AbstractFileSystem.file.impl">fs.AbstractFileSystem.file.impl</a></td><td>org.apache.hadoop.fs.local.LocalFs</td><td>The AbstractFileSystem for file: uris.</td>
</tr>
<tr>
<td><a name="fs.AbstractFileSystem.har.impl">fs.AbstractFileSystem.har.impl</a></td><td>org.apache.hadoop.fs.HarFs</td><td>The AbstractFileSystem for har: uris.</td>
</tr>
<tr>
<td><a name="fs.AbstractFileSystem.hdfs.impl">fs.AbstractFileSystem.hdfs.impl</a></td><td>org.apache.hadoop.fs.Hdfs</td><td>The FileSystem for hdfs: uris.</td>
</tr>
<tr>
<td><a name="fs.AbstractFileSystem.viewfs.impl">fs.AbstractFileSystem.viewfs.impl</a></td><td>org.apache.hadoop.fs.viewfs.ViewFs</td><td>The AbstractFileSystem for view file system for viewfs: uris
  (ie client side mount table:).</td>
</tr>
<tr>
<td><a name="fs.viewfs.rename.strategy">fs.viewfs.rename.strategy</a></td><td>SAME_MOUNTPOINT</td><td>Allowed rename strategy to rename between multiple mountpoints.
    Allowed values are SAME_MOUNTPOINT,SAME_TARGET_URI_ACROSS_MOUNTPOINT and
    SAME_FILESYSTEM_ACROSS_MOUNTPOINT.
  </td>
</tr>
<tr>
<td><a name="fs.AbstractFileSystem.ftp.impl">fs.AbstractFileSystem.ftp.impl</a></td><td>org.apache.hadoop.fs.ftp.FtpFs</td><td>The FileSystem for Ftp: uris.</td>
</tr>
<tr>
<td><a name="fs.ftp.impl">fs.ftp.impl</a></td><td>org.apache.hadoop.fs.ftp.FTPFileSystem</td><td>The implementation class of the FTP FileSystem</td>
</tr>
<tr>
<td><a name="fs.AbstractFileSystem.webhdfs.impl">fs.AbstractFileSystem.webhdfs.impl</a></td><td>org.apache.hadoop.fs.WebHdfs</td><td>The FileSystem for webhdfs: uris.</td>
</tr>
<tr>
<td><a name="fs.AbstractFileSystem.swebhdfs.impl">fs.AbstractFileSystem.swebhdfs.impl</a></td><td>org.apache.hadoop.fs.SWebHdfs</td><td>The FileSystem for swebhdfs: uris.</td>
</tr>
<tr>
<td><a name="fs.ftp.host">fs.ftp.host</a></td><td>0.0.0.0</td><td>FTP filesystem connects to this server</td>
</tr>
<tr>
<td><a name="fs.ftp.host.port">fs.ftp.host.port</a></td><td>21</td><td>
    FTP filesystem connects to fs.ftp.host on this port
  </td>
</tr>
<tr>
<td><a name="fs.ftp.data.connection.mode">fs.ftp.data.connection.mode</a></td><td>ACTIVE_LOCAL_DATA_CONNECTION_MODE</td><td>Set the FTPClient's data connection mode based on configuration.
    Valid values are ACTIVE_LOCAL_DATA_CONNECTION_MODE,
    PASSIVE_LOCAL_DATA_CONNECTION_MODE and PASSIVE_REMOTE_DATA_CONNECTION_MODE.
  </td>
</tr>
<tr>
<td><a name="fs.ftp.transfer.mode">fs.ftp.transfer.mode</a></td><td>BLOCK_TRANSFER_MODE</td><td>
    Set FTP's transfer mode based on configuration. Valid values are
    STREAM_TRANSFER_MODE, BLOCK_TRANSFER_MODE and COMPRESSED_TRANSFER_MODE.
  </td>
</tr>
<tr>
<td><a name="fs.ftp.timeout">fs.ftp.timeout</a></td><td>0</td><td>
    FTP filesystem's timeout in seconds.
  </td>
</tr>
<tr>
<td><a name="fs.df.interval">fs.df.interval</a></td><td>60000</td><td>Disk usage statistics refresh interval in msec.</td>
</tr>
<tr>
<td><a name="fs.du.interval">fs.du.interval</a></td><td>600000</td><td>File space usage statistics refresh interval in msec.</td>
</tr>
<tr>
<td><a name="fs.swift.impl">fs.swift.impl</a></td><td>org.apache.hadoop.fs.swift.snative.SwiftNativeFileSystem</td><td>The implementation class of the OpenStack Swift Filesystem</td>
</tr>
<tr>
<td><a name="fs.automatic.close">fs.automatic.close</a></td><td>true</td><td>By default, FileSystem instances are automatically closed at program
  exit using a JVM shutdown hook. Setting this property to false disables this
  behavior. This is an advanced option that should only be used by server applications
  requiring a more carefully orchestrated shutdown sequence.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.access.key">fs.s3a.access.key</a></td><td></td><td>AWS access key ID used by S3A file system. Omit for IAM role-based or provider-based authentication.</td>
</tr>
<tr>
<td><a name="fs.s3a.secret.key">fs.s3a.secret.key</a></td><td></td><td>AWS secret key used by S3A file system. Omit for IAM role-based or provider-based authentication.</td>
</tr>
<tr>
<td><a name="fs.s3a.aws.credentials.provider">fs.s3a.aws.credentials.provider</a></td><td>
    org.apache.hadoop.fs.s3a.TemporaryAWSCredentialsProvider,
    org.apache.hadoop.fs.s3a.SimpleAWSCredentialsProvider,
    com.amazonaws.auth.EnvironmentVariableCredentialsProvider,
    org.apache.hadoop.fs.s3a.auth.IAMInstanceCredentialsProvider
  </td><td>
    Comma-separated class names of credential provider classes which implement
    com.amazonaws.auth.AWSCredentialsProvider.

    When S3A delegation tokens are not enabled, this list will be used
    to directly authenticate with S3 and DynamoDB services.
    When S3A Delegation tokens are enabled, depending upon the delegation
    token binding it may be used
    to communicate wih the STS endpoint to request session/role
    credentials.

    These are loaded and queried in sequence for a valid set of credentials.
    Each listed class must implement one of the following means of
    construction, which are attempted in order:
    * a public constructor accepting java.net.URI and
        org.apache.hadoop.conf.Configuration,
    * a public constructor accepting org.apache.hadoop.conf.Configuration,
    * a public static method named getInstance that accepts no
       arguments and returns an instance of
       com.amazonaws.auth.AWSCredentialsProvider, or
    * a public default constructor.

    Specifying org.apache.hadoop.fs.s3a.AnonymousAWSCredentialsProvider allows
    anonymous access to a publicly accessible S3 bucket without any credentials.
    Please note that allowing anonymous access to an S3 bucket compromises
    security and therefore is unsuitable for most use cases. It can be useful
    for accessing public data sets without requiring AWS credentials.

    If unspecified, then the default list of credential provider classes,
    queried in sequence, is:
    * org.apache.hadoop.fs.s3a.TemporaryAWSCredentialsProvider: looks
       for session login secrets in the Hadoop configuration.
    * org.apache.hadoop.fs.s3a.SimpleAWSCredentialsProvider:
       Uses the values of fs.s3a.access.key and fs.s3a.secret.key.
    * com.amazonaws.auth.EnvironmentVariableCredentialsProvider: supports
        configuration of AWS access key ID and secret access key in
        environment variables named AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY,
        and AWS_SESSION_TOKEN as documented in the AWS SDK.
    * org.apache.hadoop.fs.s3a.auth.IAMInstanceCredentialsProvider: picks up
       IAM credentials of any EC2 VM or AWS container in which the process is running.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.session.token">fs.s3a.session.token</a></td><td></td><td>Session token, when using org.apache.hadoop.fs.s3a.TemporaryAWSCredentialsProvider
    as one of the providers.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.security.credential.provider.path">fs.s3a.security.credential.provider.path</a></td><td></td><td>
    Optional comma separated list of credential providers, a list
    which is prepended to that set in hadoop.security.credential.provider.path
  </td>
</tr>
<tr>
<td><a name="fs.s3a.assumed.role.arn">fs.s3a.assumed.role.arn</a></td><td></td><td>
    AWS ARN for the role to be assumed.
    Required if the fs.s3a.aws.credentials.provider contains
    org.apache.hadoop.fs.s3a.AssumedRoleCredentialProvider
  </td>
</tr>
<tr>
<td><a name="fs.s3a.assumed.role.session.name">fs.s3a.assumed.role.session.name</a></td><td></td><td>
    Session name for the assumed role, must be valid characters according to
    the AWS APIs.
    Only used if AssumedRoleCredentialProvider is the AWS credential provider.
    If not set, one is generated from the current Hadoop/Kerberos username.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.assumed.role.policy">fs.s3a.assumed.role.policy</a></td><td></td><td>
    JSON policy to apply to the role.
    Only used if AssumedRoleCredentialProvider is the AWS credential provider.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.assumed.role.session.duration">fs.s3a.assumed.role.session.duration</a></td><td>30m</td><td>
    Duration of assumed roles before a refresh is attempted.
    Used when session tokens are requested.
    Range: 15m to 1h
  </td>
</tr>
<tr>
<td><a name="fs.s3a.assumed.role.sts.endpoint">fs.s3a.assumed.role.sts.endpoint</a></td><td></td><td>
    AWS Security Token Service Endpoint.
    If unset, uses the default endpoint.
    Only used if AssumedRoleCredentialProvider is the AWS credential provider.
    Used by the AssumedRoleCredentialProvider and in Session and Role delegation
    tokens.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.assumed.role.sts.endpoint.region">fs.s3a.assumed.role.sts.endpoint.region</a></td><td></td><td>
    AWS Security Token Service Endpoint's region;
    Needed if fs.s3a.assumed.role.sts.endpoint points to an endpoint
    other than the default one and the v4 signature is used.
    Used by the AssumedRoleCredentialProvider and in Session and Role delegation
    tokens.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.assumed.role.credentials.provider">fs.s3a.assumed.role.credentials.provider</a></td><td>org.apache.hadoop.fs.s3a.SimpleAWSCredentialsProvider</td><td>
    List of credential providers to authenticate with the STS endpoint and
    retrieve short-lived role credentials.
    Only used if AssumedRoleCredentialProvider is the AWS credential provider.
    If unset, uses "org.apache.hadoop.fs.s3a.SimpleAWSCredentialsProvider".
  </td>
</tr>
<tr>
<td><a name="fs.s3a.delegation.tokens.enabled">fs.s3a.delegation.tokens.enabled</a></td><td>false</td><td></td>
</tr>
<tr>
<td><a name="fs.s3a.delegation.token.binding">fs.s3a.delegation.token.binding</a></td><td></td><td>
    The name of a class to provide delegation tokens support in S3A.
    If unset: delegation token support is disabled.

    Note: for job submission to actually collect these tokens,
    Kerberos must be enabled.

    Options are:
    org.apache.hadoop.fs.s3a.auth.delegation.SessionTokenBinding
    org.apache.hadoop.fs.s3a.auth.delegation.FullCredentialsTokenBinding
    and org.apache.hadoop.fs.s3a.auth.delegation.RoleTokenBinding
  </td>
</tr>
<tr>
<td><a name="fs.s3a.connection.maximum">fs.s3a.connection.maximum</a></td><td>48</td><td>Controls the maximum number of simultaneous connections to S3.
    This must be bigger than the value of fs.s3a.threads.max so as to stop
    threads being blocked waiting for new HTTPS connections.
    Why not equal? The AWS SDK transfer manager also uses these connections.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.connection.ssl.enabled">fs.s3a.connection.ssl.enabled</a></td><td>true</td><td>Enables or disables SSL connections to AWS services.
    Also sets the default port to use for the s3a proxy settings,
    when not explicitly set in fs.s3a.proxy.port.</td>
</tr>
<tr>
<td><a name="fs.s3a.endpoint">fs.s3a.endpoint</a></td><td></td><td>AWS S3 endpoint to connect to. An up-to-date list is
    provided in the AWS Documentation: regions and endpoints. Without this
    property, the standard region (s3.amazonaws.com) is assumed.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.path.style.access">fs.s3a.path.style.access</a></td><td>false</td><td>Enable S3 path style access ie disabling the default virtual hosting behaviour.
    Useful for S3A-compliant storage providers as it removes the need to set up DNS for virtual hosting.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.proxy.host">fs.s3a.proxy.host</a></td><td></td><td>Hostname of the (optional) proxy server for S3 connections.</td>
</tr>
<tr>
<td><a name="fs.s3a.proxy.port">fs.s3a.proxy.port</a></td><td></td><td>Proxy server port. If this property is not set
    but fs.s3a.proxy.host is, port 80 or 443 is assumed (consistent with
    the value of fs.s3a.connection.ssl.enabled).</td>
</tr>
<tr>
<td><a name="fs.s3a.proxy.username">fs.s3a.proxy.username</a></td><td></td><td>Username for authenticating with proxy server.</td>
</tr>
<tr>
<td><a name="fs.s3a.proxy.password">fs.s3a.proxy.password</a></td><td></td><td>Password for authenticating with proxy server.</td>
</tr>
<tr>
<td><a name="fs.s3a.proxy.domain">fs.s3a.proxy.domain</a></td><td></td><td>Domain for authenticating with proxy server.</td>
</tr>
<tr>
<td><a name="fs.s3a.proxy.workstation">fs.s3a.proxy.workstation</a></td><td></td><td>Workstation for authenticating with proxy server.</td>
</tr>
<tr>
<td><a name="fs.s3a.attempts.maximum">fs.s3a.attempts.maximum</a></td><td>20</td><td>How many times we should retry commands on transient errors.</td>
</tr>
<tr>
<td><a name="fs.s3a.connection.establish.timeout">fs.s3a.connection.establish.timeout</a></td><td>5000</td><td>Socket connection setup timeout in milliseconds.</td>
</tr>
<tr>
<td><a name="fs.s3a.connection.timeout">fs.s3a.connection.timeout</a></td><td>200000</td><td>Socket connection timeout in milliseconds.</td>
</tr>
<tr>
<td><a name="fs.s3a.socket.send.buffer">fs.s3a.socket.send.buffer</a></td><td>8192</td><td>Socket send buffer hint to amazon connector. Represented in bytes.</td>
</tr>
<tr>
<td><a name="fs.s3a.socket.recv.buffer">fs.s3a.socket.recv.buffer</a></td><td>8192</td><td>Socket receive buffer hint to amazon connector. Represented in bytes.</td>
</tr>
<tr>
<td><a name="fs.s3a.paging.maximum">fs.s3a.paging.maximum</a></td><td>5000</td><td>How many keys to request from S3 when doing
     directory listings at a time.</td>
</tr>
<tr>
<td><a name="fs.s3a.threads.max">fs.s3a.threads.max</a></td><td>64</td><td>The total number of threads available in the filesystem for data
    uploads *or any other queued filesystem operation*.</td>
</tr>
<tr>
<td><a name="fs.s3a.threads.keepalivetime">fs.s3a.threads.keepalivetime</a></td><td>60</td><td>Number of seconds a thread can be idle before being
    terminated.</td>
</tr>
<tr>
<td><a name="fs.s3a.max.total.tasks">fs.s3a.max.total.tasks</a></td><td>32</td><td>The number of operations which can be queued for execution.
  This is in addition to the number of active threads in fs.s3a.threads.max.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.executor.capacity">fs.s3a.executor.capacity</a></td><td>16</td><td>The maximum number of submitted tasks which is a single
    operation (e.g. rename(), delete()) may submit simultaneously for
    execution -excluding the IO-heavy block uploads, whose capacity
    is set in "fs.s3a.fast.upload.active.blocks"

    All tasks are submitted to the shared thread pool whose size is
    set in "fs.s3a.threads.max"; the value of capacity should be less than that
    of the thread pool itself, as the goal is to stop a single operation
    from overloading that thread pool.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.multipart.size">fs.s3a.multipart.size</a></td><td>64M</td><td>How big (in bytes) to split upload or copy operations up into.
    A suffix from the set {K,M,G,T,P} may be used to scale the numeric value.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.multipart.threshold">fs.s3a.multipart.threshold</a></td><td>128M</td><td>How big (in bytes) to split upload or copy operations up into.
    This also controls the partition size in renamed files, as rename() involves
    copying the source file(s).
    A suffix from the set {K,M,G,T,P} may be used to scale the numeric value.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.multiobjectdelete.enable">fs.s3a.multiobjectdelete.enable</a></td><td>true</td><td>When enabled, multiple single-object delete requests are replaced by
    a single 'delete multiple objects'-request, reducing the number of requests.
    Beware: legacy S3-compatible object stores might not support this request.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.acl.default">fs.s3a.acl.default</a></td><td></td><td>Set a canned ACL for newly created and copied objects. Value may be Private,
      PublicRead, PublicReadWrite, AuthenticatedRead, LogDeliveryWrite, BucketOwnerRead,
      or BucketOwnerFullControl.</td>
</tr>
<tr>
<td><a name="fs.s3a.multipart.purge">fs.s3a.multipart.purge</a></td><td>false</td><td>True if you want to purge existing multipart uploads that may not have been
    completed/aborted correctly. The corresponding purge age is defined in
    fs.s3a.multipart.purge.age.
    If set, when the filesystem is instantiated then all outstanding uploads
    older than the purge age will be terminated -across the entire bucket.
    This will impact multipart uploads by other applications and users. so should
    be used sparingly, with an age value chosen to stop failed uploads, without
    breaking ongoing operations.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.multipart.purge.age">fs.s3a.multipart.purge.age</a></td><td>86400</td><td>Minimum age in seconds of multipart uploads to purge
    on startup if "fs.s3a.multipart.purge" is true
  </td>
</tr>
<tr>
<td><a name="fs.s3a.server-side-encryption-algorithm">fs.s3a.server-side-encryption-algorithm</a></td><td></td><td>Specify a server-side encryption algorithm for s3a: file system.
    Unset by default.  It supports the following values: 'AES256' (for SSE-S3),
    'SSE-KMS' and 'SSE-C'.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.server-side-encryption.key">fs.s3a.server-side-encryption.key</a></td><td></td><td>Specific encryption key to use if fs.s3a.server-side-encryption-algorithm
    has been set to 'SSE-KMS' or 'SSE-C'. In the case of SSE-C, the value of this property
    should be the Base64 encoded key. If you are using SSE-KMS and leave this property empty,
    you'll be using your default's S3 KMS key, otherwise you should set this property to
    the specific KMS key id.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.signing-algorithm">fs.s3a.signing-algorithm</a></td><td></td><td>Override the default signing algorithm so legacy
    implementations can still be used</td>
</tr>
<tr>
<td><a name="fs.s3a.block.size">fs.s3a.block.size</a></td><td>32M</td><td>Block size to use when reading files using s3a: file system.
    A suffix from the set {K,M,G,T,P} may be used to scale the numeric value.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.buffer.dir">fs.s3a.buffer.dir</a></td><td>${hadoop.tmp.dir}/s3a</td><td>Comma separated list of directories that will be used to buffer file
    uploads to.</td>
</tr>
<tr>
<td><a name="fs.s3a.fast.upload.buffer">fs.s3a.fast.upload.buffer</a></td><td>disk</td><td>
    The buffering mechanism to for data being written.
    Values: disk, array, bytebuffer.

    "disk" will use the directories listed in fs.s3a.buffer.dir as
    the location(s) to save data prior to being uploaded.

    "array" uses arrays in the JVM heap

    "bytebuffer" uses off-heap memory within the JVM.

    Both "array" and "bytebuffer" will consume memory in a single stream up to the number
    of blocks set by:

        fs.s3a.multipart.size * fs.s3a.fast.upload.active.blocks.

    If using either of these mechanisms, keep this value low

    The total number of threads performing work across all threads is set by
    fs.s3a.threads.max, with fs.s3a.max.total.tasks values setting the number of queued
    work items.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.fast.upload.active.blocks">fs.s3a.fast.upload.active.blocks</a></td><td>4</td><td>
    Maximum Number of blocks a single output stream can have
    active (uploading, or queued to the central FileSystem
    instance's pool of queued operations.

    This stops a single stream overloading the shared thread pool.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.readahead.range">fs.s3a.readahead.range</a></td><td>64K</td><td>Bytes to read ahead during a seek() before closing and
  re-opening the S3 HTTP connection. This option will be overridden if
  any call to setReadahead() is made to an open stream.
  A suffix from the set {K,M,G,T,P} may be used to scale the numeric value.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.user.agent.prefix">fs.s3a.user.agent.prefix</a></td><td></td><td>
    Sets a custom value that will be prepended to the User-Agent header sent in
    HTTP requests to the S3 back-end by S3AFileSystem.  The User-Agent header
    always includes the Hadoop version number followed by a string generated by
    the AWS SDK.  An example is "User-Agent: Hadoop 2.8.0, aws-sdk-java/1.10.6".
    If this optional property is set, then its value is prepended to create a
    customized User-Agent.  For example, if this configuration property was set
    to "MyApp", then an example of the resulting User-Agent would be
    "User-Agent: MyApp, Hadoop 2.8.0, aws-sdk-java/1.10.6".
  </td>
</tr>
<tr>
<td><a name="fs.s3a.metadatastore.authoritative">fs.s3a.metadatastore.authoritative</a></td><td>false</td><td>
        When true, allow MetadataStore implementations to act as source of
        truth for getting file status and directory listings.  Even if this
        is set to true, MetadataStore implementations may choose not to
        return authoritative results.  If the configured MetadataStore does
        not support being authoritative, this setting will have no effect.
    </td>
</tr>
<tr>
<td><a name="fs.s3a.metadatastore.metadata.ttl">fs.s3a.metadatastore.metadata.ttl</a></td><td>15m</td><td>
        This value sets how long an entry in a MetadataStore is valid.
    </td>
</tr>
<tr>
<td><a name="fs.s3a.metadatastore.impl">fs.s3a.metadatastore.impl</a></td><td>org.apache.hadoop.fs.s3a.s3guard.NullMetadataStore</td><td>
        Fully-qualified name of the class that implements the MetadataStore
        to be used by s3a.  The default class, NullMetadataStore, has no
        effect: s3a will continue to treat the backing S3 service as the one
        and only source of truth for file and directory metadata.
    </td>
</tr>
<tr>
<td><a name="fs.s3a.metadatastore.fail.on.write.error">fs.s3a.metadatastore.fail.on.write.error</a></td><td>true</td><td>
    When true (default), FileSystem write operations generate
    org.apache.hadoop.fs.s3a.MetadataPersistenceException if the metadata
    cannot be saved to the metadata store.  When false, failures to save to
    metadata store are logged at ERROR level, but the overall FileSystem
    write operation succeeds.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.cli.prune.age">fs.s3a.s3guard.cli.prune.age</a></td><td>86400000</td><td>
        Default age (in milliseconds) after which to prune metadata from the
        metadatastore when the prune command is run.  Can be overridden on the
        command-line.
    </td>
</tr>
<tr>
<td><a name="fs.s3a.impl">fs.s3a.impl</a></td><td>org.apache.hadoop.fs.s3a.S3AFileSystem</td><td>The implementation class of the S3A Filesystem</td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.ddb.region">fs.s3a.s3guard.ddb.region</a></td><td></td><td>
    AWS DynamoDB region to connect to. An up-to-date list is
    provided in the AWS Documentation: regions and endpoints. Without this
    property, the S3Guard will operate table in the associated S3 bucket region.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.ddb.table">fs.s3a.s3guard.ddb.table</a></td><td></td><td>
    The DynamoDB table name to operate. Without this property, the respective
    S3 bucket name will be used.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.ddb.table.create">fs.s3a.s3guard.ddb.table.create</a></td><td>false</td><td>
    If true, the S3A client will create the table if it does not already exist.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.ddb.table.capacity.read">fs.s3a.s3guard.ddb.table.capacity.read</a></td><td>0</td><td>
    Provisioned throughput requirements for read operations in terms of capacity
    units for the DynamoDB table. This config value will only be used when
    creating a new DynamoDB table.
    If set to 0 (the default), new tables are created with "per-request" capacity.
    If a positive integer is provided for this and the write capacity, then
    a table with "provisioned capacity" will be created.
    You can change the capacity of an existing provisioned-capacity table
    through the "s3guard set-capacity" command.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.ddb.table.capacity.write">fs.s3a.s3guard.ddb.table.capacity.write</a></td><td>0</td><td>
    Provisioned throughput requirements for write operations in terms of
    capacity units for the DynamoDB table.
    If set to 0 (the default), new tables are created with "per-request" capacity.
    Refer to related configuration option fs.s3a.s3guard.ddb.table.capacity.read
  </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.ddb.table.sse.enabled">fs.s3a.s3guard.ddb.table.sse.enabled</a></td><td>false</td><td>
    Whether server-side encryption (SSE) is enabled or disabled on the table.
    By default it's disabled, meaning SSE is set to AWS owned CMK.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.ddb.table.sse.cmk">fs.s3a.s3guard.ddb.table.sse.cmk</a></td><td></td><td>
    The KMS Customer Master Key (CMK) used for the KMS encryption on the table.
    To specify a CMK, this config value can be its key ID, Amazon Resource Name
    (ARN), alias name, or alias ARN. Users only need to provide this config if
    the key is different from the default DynamoDB KMS Master Key, which is
    alias/aws/dynamodb.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.ddb.max.retries">fs.s3a.s3guard.ddb.max.retries</a></td><td>9</td><td>
      Max retries on throttled/incompleted DynamoDB operations
      before giving up and throwing an IOException.
      Each retry is delayed with an exponential
      backoff timer which starts at 100 milliseconds and approximately
      doubles each time.  The minimum wait before throwing an exception is
      sum(100, 200, 400, 800, .. 100*2^N-1 ) == 100 * ((2^N)-1)
    </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.ddb.throttle.retry.interval">fs.s3a.s3guard.ddb.throttle.retry.interval</a></td><td>100ms</td><td>
      Initial interval to retry after a request is throttled events;
      the back-off policy is exponential until the number of retries of
      fs.s3a.s3guard.ddb.max.retries is reached.
    </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.ddb.background.sleep">fs.s3a.s3guard.ddb.background.sleep</a></td><td>25ms</td><td>
    Length (in milliseconds) of pause between each batch of deletes when
    pruning metadata.  Prevents prune operations (which can typically be low
    priority background operations) from overly interfering with other I/O
    operations.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.retry.limit">fs.s3a.retry.limit</a></td><td>7</td><td>
    Number of times to retry any repeatable S3 client request on failure,
    excluding throttling requests and S3Guard inconsistency resolution.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.retry.interval">fs.s3a.retry.interval</a></td><td>500ms</td><td>
    Initial retry interval when retrying operations for any reason other
    than S3 throttle errors and S3Guard inconsistency resolution.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.retry.throttle.limit">fs.s3a.retry.throttle.limit</a></td><td>20</td><td>
    Number of times to retry any throttled request.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.retry.throttle.interval">fs.s3a.retry.throttle.interval</a></td><td>100ms</td><td>
    Initial between retry attempts on throttled requests, +/- 50%. chosen at random.
    i.e. for an intial value of 3000ms, the initial delay would be in the range 1500ms to 4500ms.
    Backoffs are exponential; again randomness is used to avoid the thundering heard problem.
    500ms is the default value used by the AWS S3 Retry policy.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.consistency.retry.limit">fs.s3a.s3guard.consistency.retry.limit</a></td><td>7</td><td>
    Number of times to retry attempts to read/open/copy files when
    S3Guard believes a specific version of the file to be available,
    but the S3 request does not find any version of a file, or a different
    version.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.s3guard.consistency.retry.interval">fs.s3a.s3guard.consistency.retry.interval</a></td><td>2s</td><td>
    Initial interval between attempts to retry operations while waiting for S3
    to become consistent with the S3Guard data.
    An exponential back-off is used here: every failure doubles the delay.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.committer.name">fs.s3a.committer.name</a></td><td>file</td><td>
    Committer to create for output to S3A, one of:
    "file", "directory", "partitioned", "magic".
  </td>
</tr>
<tr>
<td><a name="fs.s3a.committer.magic.enabled">fs.s3a.committer.magic.enabled</a></td><td>false</td><td>
    Enable support in the filesystem for the S3 "Magic" committer.
    When working with AWS S3, S3Guard must be enabled for the destination
    bucket, as consistent metadata listings are required.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.committer.threads">fs.s3a.committer.threads</a></td><td>8</td><td>
    Number of threads in committers for parallel operations on files
    (upload, commit, abort, delete...)
  </td>
</tr>
<tr>
<td><a name="fs.s3a.committer.staging.tmp.path">fs.s3a.committer.staging.tmp.path</a></td><td>tmp/staging</td><td>
    Path in the cluster filesystem for temporary data.
    This is for HDFS, not the local filesystem.
    It is only for the summary data of each file, not the actual
    data being committed.
    Using an unqualified path guarantees that the full path will be
    generated relative to the home directory of the user creating the job,
    hence private (assuming home directory permissions are secure).
  </td>
</tr>
<tr>
<td><a name="fs.s3a.committer.staging.unique-filenames">fs.s3a.committer.staging.unique-filenames</a></td><td>true</td><td>
    Option for final files to have a unique name through job attempt info,
    or the value of fs.s3a.committer.staging.uuid
    When writing data with the "append" conflict option, this guarantees
    that new data will not overwrite any existing data.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.committer.staging.conflict-mode">fs.s3a.committer.staging.conflict-mode</a></td><td>append</td><td>
    Staging committer conflict resolution policy.
    Supported: "fail", "append", "replace".
  </td>
</tr>
<tr>
<td><a name="fs.s3a.committer.staging.abort.pending.uploads">fs.s3a.committer.staging.abort.pending.uploads</a></td><td>true</td><td>
    Should the staging committers abort all pending uploads to the destination
    directory?

    Changing this if more than one partitioned committer is
    writing to the same destination tree simultaneously; otherwise
    the first job to complete will cancel all outstanding uploads from the
    others. However, it may lead to leaked outstanding uploads from failed
    tasks. If disabled, configure the bucket lifecycle to remove uploads
    after a time period, and/or set up a workflow to explicitly delete
    entries. Otherwise there is a risk that uncommitted uploads may run up
    bills.
  </td>
</tr>
<tr>
<td><a name="fs.s3a.select.enabled">fs.s3a.select.enabled</a></td><td>true</td><td>Is S3 Select enabled?</td>
</tr>
<tr>
<td><a name="fs.s3a.select.input.csv.comment.marker">fs.s3a.select.input.csv.comment.marker</a></td><td>#</td><td>In S3 Select queries: the marker for comment lines in CSV files</td>
</tr>
<tr>
<td><a name="fs.s3a.select.input.csv.record.delimiter">fs.s3a.select.input.csv.record.delimiter</a></td><td>\n</td><td>In S3 Select queries over CSV files: the record delimiter.
    \t is remapped to the TAB character, \r to CR \n to newline. \\ to \
    and \" to "
  </td>
</tr>
<tr>
<td><a name="fs.s3a.select.input.csv.field.delimiter">fs.s3a.select.input.csv.field.delimiter</a></td><td>,</td><td>In S3 Select queries over CSV files: the field delimiter.
    \t is remapped to the TAB character, \r to CR \n to newline. \\ to \
    and \" to "
  </td>
</tr>
<tr>
<td><a name="fs.s3a.select.input.csv.quote.character">fs.s3a.select.input.csv.quote.character</a></td><td>"</td><td>In S3 Select queries over CSV files: quote character.
    \t is remapped to the TAB character, \r to CR \n to newline. \\ to \
    and \" to "
  </td>
</tr>
<tr>
<td><a name="fs.s3a.select.input.csv.quote.escape.character">fs.s3a.select.input.csv.quote.escape.character</a></td><td>\\</td><td>In S3 Select queries over CSV files: quote escape character.
    \t is remapped to the TAB character, \r to CR \n to newline. \\ to \
    and \" to "
  </td>
</tr>
<tr>
<td><a name="fs.s3a.select.input.csv.header">fs.s3a.select.input.csv.header</a></td><td>none</td><td>In S3 Select queries over CSV files: what is the role of the header? One of "none", "ignore" and "use"</td>
</tr>
<tr>
<td><a name="fs.s3a.select.input.compression">fs.s3a.select.input.compression</a></td><td>none</td><td>In S3 Select queries, the source compression
    algorithm. One of: "none" and "gzip"</td>
</tr>
<tr>
<td><a name="fs.s3a.select.output.csv.quote.fields">fs.s3a.select.output.csv.quote.fields</a></td><td>always</td><td>
    In S3 Select queries: should fields in generated CSV Files be quoted?
    One of: "always", "asneeded".
  </td>
</tr>
<tr>
<t